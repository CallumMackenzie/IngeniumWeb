<!doctype html>
<html>

<head>
    <title>Ingenium Web</title>
</head>

<body style="height: 100%; width: 100%; margin : 0; overflow : hidden;">
    <div id="root" style="margin: 0; background-color: whitesmoke; position: absolute;"></div>

    <script type="module">
        "use strict"; export let gl; export class Input { static setup() { window.addEventListener("keydown", function (e) { 1 != e.ctrlKey || 61 !== e.which && 107 !== e.which && 173 !== e.which && 109 !== e.which && 187 !== e.which && 189 !== e.which || e.preventDefault(), Input.keys[e.key] = !0 }, !0), window.addEventListener("keyup", function (e) { Input.keys[e.key] = !1 }, !0) } static getKeyState(e) { return void 0 !== Input.keys[e] && Input.keys[e] } } Input.keys = {}; export class Time { static setFPS(e) { e <= 0 && IngeniumWeb.terminate("Error: FPS cannot be less than or equal to 0."), Time.targetDeltaTime = 1e3 / e } static setFixedFPS(e) { e <= 0 && IngeniumWeb.terminate("Error: FPS cannot be less than or equal to 0."), Time.targetFixedDeltaTime = 1e3 / e } static updateDeltaTime() { Time.deltaTime = (Date.now() - Time.lastFrame) / 1e3, Time.lastFrame = Date.now() } static updateFixedDeltaTime() { Time.fixedDeltaTime = (Date.now() - Time.lastFixedFrame) / 1e3, Time.lastFixedFrame = Date.now() } static nextFixedFrameReady() { return Date.now() - Time.lastFixedFrame >= Time.targetFixedDeltaTime && (Time.updateFixedDeltaTime(), !0) } static nextFrameReady() { return Date.now() - Time.lastFrame >= Time.targetDeltaTime && (Time.updateDeltaTime(), !0) } static deltaTimeToFPS(e) { return 1 / e } } Time.deltaTime = .1, Time.fixedDeltaTime = .1, Time.targetDeltaTime = 1e3 / 45, Time.targetFixedDeltaTime = 1e3 / 35, Time.lastFrame = Date.now(), Time.lastFixedFrame = Date.now(); export class WebGLWindow { constructor(e, t, r, i) { this.takeUpAsepct = !0, this.parent = document.getElementById(r), this.canvas = document.createElement("canvas"), this.canvas.setAttribute("width", e.toString() + "px"), this.canvas.setAttribute("height", t.toString() + "px"), this.canvas.setAttribute("id", i), this.parent.appendChild(this.canvas), this.width = e, this.height = t, this.aspectRatio = t / e, this.setGL() } sizeToWindow(e) { e = 1 / e; let t = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0), r = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0); t / r != e && (r * e < t ? (this.canvas.width = r * e, this.canvas.height = r, this.canvas.style.setProperty("height", this.canvas.height + "px"), this.canvas.style.setProperty("width", this.canvas.width.toString() + "px")) : r * e > t && (this.canvas.width = t, this.canvas.height = t / e, this.canvas.style.setProperty("width", this.canvas.width + "px"), this.canvas.style.setProperty("height", this.canvas.height.toString() + "px")), this.width = this.canvas.width, this.height = this.canvas.height, FrameBuffer.bindDefault(), gl.viewport(0, 0, gl.canvas.width, gl.canvas.height)) } setGL() { gl = this.canvas.getContext(IngeniumWeb.glVersion) } setClearColour(e, t) { gl.clearDepth(1); let r = (16711680 & e) >> 16, i = (65280 & e) >> 8, a = 255 & e; gl.clearColor(r / 255, i / 255, a / 255, t); let n = { prop: "background", val: "rgb(" + r.toString() + "," + i.toString() + "," + a.toString() + ")" }; this.parent.style.setProperty(n.prop, n.val), document.body.style.setProperty(n.prop, n.val) } clear() { gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT) } } export class Scene { constructor(e = function () { }, t = function () { }, r = function () { }, i = function () { }) { this.onCreate = e, this.onClose = r, this.onUpdate = t, this.onFixedUpdate = i } } export class IngeniumWeb { static start(e, t = function () { }, r = function () { }, i = function () { }, a = function () { }, n = "webgl2") { this.startTime = Date.now(), IngeniumWeb.window = null, IngeniumWeb.running = !0, IngeniumWeb.scenes = e, IngeniumWeb.onCreate = t, IngeniumWeb.onUpdate = r, IngeniumWeb.onClose = i, IngeniumWeb.onFixedUpdate = a, IngeniumWeb.glVersion = n, Input.setup(), IngeniumWeb.init() } static createWindow(e, t, r, i = "root", a = !0) { IngeniumWeb.window = new WebGLWindow(e, t, i, r), IngeniumWeb.window.takeUpAsepct = a, a && window.addEventListener("resize", function () { IngeniumWeb.window.sizeToWindow(IngeniumWeb.window.aspectRatio) }) } static update() { Time.updateDeltaTime(), IngeniumWeb.onUpdate(), IngeniumWeb.scenes[IngeniumWeb.currentScene].onUpdate() } static fixedUpdate() { Time.updateFixedDeltaTime(), IngeniumWeb.onFixedUpdate(), IngeniumWeb.scenes[IngeniumWeb.currentScene].onFixedUpdate(), IngeniumWeb.running || (IngeniumWeb.scenes[IngeniumWeb.currentScene].onClose(), IngeniumWeb.onClose(), clearInterval(IngeniumWeb.intervalCode), clearInterval(IngeniumWeb.fixedIntervalCode)) } static init() { Time.updateDeltaTime(), Time.updateFixedDeltaTime(), IngeniumWeb.onCreate(), IngeniumWeb.scenes[IngeniumWeb.currentScene].onCreate(), IngeniumWeb.refreshLoops(), IngeniumWeb.window.takeUpAsepct && IngeniumWeb.window.sizeToWindow(IngeniumWeb.window.aspectRatio) } static refreshLoops() { clearInterval(IngeniumWeb.intervalCode), clearInterval(IngeniumWeb.fixedIntervalCode), IngeniumWeb.intervalCode = setInterval(IngeniumWeb.update, Time.targetDeltaTime), IngeniumWeb.fixedIntervalCode = setInterval(IngeniumWeb.fixedUpdate, Time.targetFixedDeltaTime) } static terminate(e) { console.error("Fatal: " + e), IngeniumWeb.running = !1, clearInterval(IngeniumWeb.intervalCode), clearInterval(IngeniumWeb.fixedIntervalCode) } static enterScene(e) { IngeniumWeb.currentScene = e, IngeniumWeb.scenes[IngeniumWeb.currentScene].onCreate() } static defaultSetup() { gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA), gl.enable(gl.BLEND), gl.enable(gl.DEPTH_TEST), gl.depthMask(!0), gl.depthFunc(gl.LEQUAL), gl.depthRange(0, 1) } } IngeniumWeb.scenes = [], IngeniumWeb.currentScene = 0, IngeniumWeb.startTime = 0; export let PI = 355 / 113; export class Vec2 { constructor(e = 0, t = 0, r = 1) { this.x = 0, this.y = 0, this.w = 1, this.x = e, this.y = t, this.w = r } static filledWith(e) { return new Vec2(e, e) } static sub(e, t) { return new Vec2(e.x - t.x, e.y - t.y) } static add(e, t) { return new Vec2(e.x + t.x, e.y + t.y) } static mul(e, t) { return new Vec2(e.x * t.x, e.y * t.y) } static div(e, t) { return new Vec2(e.x / t.x, e.y / t.y) } static mulFloat(e, t) { return new Vec2(e.x * t, e.y * t) } static divFloat(e, t) { return new Vec2(e.x / t, e.y / t) } static len(e) { return Math.sqrt(e.x * e.x + e.y * e.y) } static normalize(e) { let t = Vec2.len(e); return new Vec2(e.x / t, e.y / t) } sub(e) { return Vec2.sub(this, e) } add(e) { return Vec2.add(this, e) } mul(e) { return Vec2.mul(this, e) } div(e) { return Vec2.div(this, e) } mulFloat(e) { return Vec2.mulFloat(this, e) } divFloat(e) { return Vec2.divFloat(this, e) } len() { return Vec2.len(this) } normalized() { return Vec2.normalize(this) } } export class Vec3 { constructor(e = 0, t = 0, r = 0, i = 1) { this.x = 0, this.y = 0, this.z = 0, this.w = 1, this.x = e, this.y = t, this.z = r, this.w = i } static filledWith(e) { return new Vec3(e, e, e) } static sub(e, t) { return new Vec3(e.x - t.x, e.y - t.y, e.z - t.z) } static add(e, t) { return new Vec3(e.x + t.x, e.y + t.y, e.z + t.z) } static mul(e, t) { return new Vec3(e.x * t.x, e.y * t.y, e.z * t.z) } static div(e, t) { return new Vec3(e.x / t.x, e.y / t.y, e.z / t.z) } static mulFloat(e, t) { return new Vec3(e.x * t, e.y * t, e.z * t) } static divFloat(e, t) { return new Vec3(e.x / t, e.y / t, e.z / t) } static addFloat(e, t) { return new Vec3(e.x + t, e.y + t, e.z + t) } static subFloat(e, t) { return new Vec3(e.x - t, e.y - t, e.z - t) } static dot(e, t) { return e.x * t.x + e.y * t.y + e.z * t.z } static len(e) { return Math.sqrt(Vec3.dot(e, e)) } static normalize(e) { let t = Vec3.len(e); return 0 != t ? new Vec3(e.x / t, e.y / t, e.z / t) : new Vec3 } static cross(e, t) { let r = new Vec3; return r.x = e.y * t.z - e.z * t.y, r.y = e.z * t.x - e.x * t.z, r.z = e.x * t.y - e.y * t.x, r } static mulMat(e, t) { let r = new Vec3; return r.x = e.x * t.m[0][0] + e.y * t.m[1][0] + e.z * t.m[2][0] + e.w * t.m[3][0], r.y = e.x * t.m[0][1] + e.y * t.m[1][1] + e.z * t.m[2][1] + e.w * t.m[3][1], r.z = e.x * t.m[0][2] + e.y * t.m[1][2] + e.z * t.m[2][2] + e.w * t.m[3][2], r.w = e.x * t.m[0][3] + e.y * t.m[1][3] + e.z * t.m[2][3] + e.w * t.m[3][3], r } add(e) { return Vec3.add(this, e) } sub(e) { return Vec3.sub(this, e) } mul(e) { return Vec3.mul(this, e) } div(e) { return Vec3.div(this, e) } mulFloat(e) { return Vec3.mulFloat(this, e) } divFloat(e) { return Vec3.divFloat(this, e) } addFloat(e) { return Vec3.addFloat(this, e) } subFloat(e) { return Vec3.subFloat(this, e) } len() { return Vec3.len(this) } mulMat(e) { return Vec3.mulMat(this, e) } normalized() { return Vec3.normalize(this) } isNaN() { return isNaN(this.x) || isNaN(this.y) || isNaN(this.z) || isNaN(this.w) } equals(e) { return this.x == e.x && this.y == e.y && this.z == e.z } } export class Mat2 { constructor(e = [[0, 0], [0, 0]]) { this.m = e } flatten() { return [this.m[0][0], this.m[0][1], this.m[1][0], this.m[1][1]] } determinant() { return this.m[0][0] * this.m[1][1] - this.m[0][1] * this.m[1][0] } inverse() { return Mat2.inverse(this) } mul(e) { let t = new Mat2(this.m); for (let r = 0; r < e.length; r++) { let i = e[r], a = new Mat2; for (let e = 0; e < 2; e++)for (let r = 0; r < 2; r++)a.m[r][e] = t.m[r][0] * i.m[0][e] + t.m[r][1] * i.m[1][e]; t = a } return t } static scale(e) { let t = new Mat2; return t.m[0][0] = e.x, t.m[1][1] = e.y, t } static rotation(e) { let t = new Mat2; return t.m[0][0] = Math.cos(e), t.m[0][1] = Math.sin(e), t.m[1][0] = -Math.sin(e), t.m[1][1] = Math.cos(e), t } static identity() { let e = new Mat2; return e.m[0][0] = 1, e.m[1][1] = 0, e } static inverse(e) { let t = e.determinant(), r = new Mat2; return r.m[0][0] = e.m[0][0] / t, r.m[1][1] = e.m[1][1] / t, r.m[1][0] = e.m[1][0] / t, r.m[0][1] = e.m[0][1] / t, r } } export class Mat4 { constructor() { this.m = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]] } static perspective(e, t, r, i) { let a = 1 / Math.tan(Rotation.degToRad(.5 * e)), n = new Mat4; return n.m[0][0] = t * a, n.m[1][1] = a, n.m[2][2] = i / (i - r), n.m[3][2] = -i * r / (i - r), n.m[2][3] = 1, n.m[3][3] = 0, n } static inverse(e) { let t = new Mat4; return t.m[0][0] = e.m[0][0], t.m[0][1] = e.m[1][0], t.m[0][2] = e.m[2][0], t.m[0][3] = 0, t.m[1][0] = e.m[0][1], t.m[1][1] = e.m[1][1], t.m[1][2] = e.m[2][1], t.m[1][3] = 0, t.m[2][0] = e.m[0][2], t.m[2][1] = e.m[1][2], t.m[2][2] = e.m[2][2], t.m[2][3] = 0, t.m[3][0] = -(e.m[3][0] * t.m[0][0] + e.m[3][1] * t.m[1][0] + e.m[3][2] * t.m[2][0]), t.m[3][1] = -(e.m[3][0] * t.m[0][1] + e.m[3][1] * t.m[1][1] + e.m[3][2] * t.m[2][1]), t.m[3][2] = -(e.m[3][0] * t.m[0][2] + e.m[3][1] * t.m[1][2] + e.m[3][2] * t.m[2][2]), t.m[3][3] = 1, t } static identity() { let e = new Mat4; return e.m[0][0] = 1, e.m[1][1] = 1, e.m[2][2] = 1, e.m[3][3] = 1, e } static pointedAt(e, t, r = new Vec3(0, 1, 0)) { let i = Vec3.sub(t, e); i = Vec3.normalize(i); let a = Vec3.mulFloat(i, Vec3.dot(r, i)), n = Vec3.sub(r, a); n = Vec3.normalize(n); let s = Vec3.cross(n, i), l = new Mat4; return l.m[0][0] = s.x, l.m[0][1] = s.y, l.m[0][2] = s.z, l.m[0][3] = 0, l.m[1][0] = n.x, l.m[1][1] = n.y, l.m[1][2] = n.z, l.m[1][3] = 0, l.m[2][0] = i.x, l.m[2][1] = i.y, l.m[2][2] = i.z, l.m[2][3] = 0, l.m[3][0] = e.x, l.m[3][1] = e.y, l.m[3][2] = e.z, l.m[3][3] = 1, l } static scale(e = 1, t = 1, r = 1) { let i = Mat4.identity(); return i.m[0][0] = e, i.m[1][1] = t, i.m[2][2] = r, i } static translation(e = 0, t = 0, r = 0) { let i = new Mat4; return i.m[0][0] = 1, i.m[1][1] = 1, i.m[2][2] = 1, i.m[3][3] = 1, i.m[3][0] = e, i.m[3][1] = t, i.m[3][2] = r, i } static mul(e, t) { let r = new Mat4; for (let i = 0; i < 4; i++)for (let a = 0; a < 4; a++)r.m[a][i] = e.m[a][0] * t.m[0][i] + e.m[a][1] * t.m[1][i] + e.m[a][2] * t.m[2][i] + e.m[a][3] * t.m[3][i]; return r } static rotationX(e) { let t = new Mat4; return t.m[0][0] = 1, t.m[1][1] = Math.cos(e), t.m[1][2] = Math.sin(e), t.m[2][1] = -Math.sin(e), t.m[2][2] = Math.cos(e), t.m[3][3] = 1, t } static rotationY(e) { let t = new Mat4; return t.m[0][0] = Math.cos(e), t.m[0][2] = Math.sin(e), t.m[2][0] = -Math.sin(e), t.m[1][1] = 1, t.m[2][2] = Math.cos(e), t.m[3][3] = 1, t } static rotationZ(e) { let t = new Mat4; return t.m[0][0] = Math.cos(e), t.m[0][1] = Math.sin(e), t.m[1][0] = -Math.sin(e), t.m[1][1] = Math.cos(e), t.m[2][2] = 1, t.m[3][3] = 1, t } static rotationOnPoint(e, t) { return Mat4.mul(Mat4.mul(Mat4.translation(t.x, t.y, t.z), Mat4.mul(Mat4.mul(Mat4.rotationX(e.x), Mat4.rotationY(e.y)), Mat4.rotationZ(e.z))), Mat4.translation(-t.x, -t.y, -t.z)) } } export class Rotation { static radToDeg(e) { return 180 * e / PI } static degToRad(e) { return e * PI / 180 } } export class ShaderUniforms { } ShaderUniforms.material_diffuse = "material.diffuse", ShaderUniforms.material_specular = "material.specular", ShaderUniforms.material_normal = "material.normal", ShaderUniforms.material_parallax = "material.parallax", ShaderUniforms.material_heightScale = "material.heightScale", ShaderUniforms.material_shininess = "material.shininess", ShaderUniforms.material_scaleUV = "mesh.scaleUV", ShaderUniforms.pointLight_structName = "pointLights", ShaderUniforms.pointLight_position = "position", ShaderUniforms.pointLight_ambient = "ambient", ShaderUniforms.pointLight_diffuse = "diffuse", ShaderUniforms.pointLight_specular = "specular", ShaderUniforms.pointLight_constant = "constant", ShaderUniforms.pointLight_linear = "linear", ShaderUniforms.pointLight_quadratic = "quadratic", ShaderUniforms.directionalLight_direction = "dirLight.direction", ShaderUniforms.directionalLight_ambient = "dirLight.ambient", ShaderUniforms.directionalLight_specular = "dirLight.specular", ShaderUniforms.directionalLight_diffuse = "dirLight.diffuse", ShaderUniforms.mesh3D_modelMatrix = "mesh.transform", ShaderUniforms.mesh3D_invModelMatrix = "mesh.inverseTransform", ShaderUniforms.mesh3D_tint = "mesh.tint", ShaderUniforms.ingenium_time = "u_time", ShaderUniforms.camera3D_view = "camera.view", ShaderUniforms.camera3D_projection = "camera.projection", ShaderUniforms.camera3D_viewPos = "viewPos", ShaderUniforms.shader_numLights = "numlights", ShaderUniforms.camera2D_translation = "camera.translation", ShaderUniforms.camera2D_rotation = "camera.rotation", ShaderUniforms.camera2D_rotationPoint = "camera.rotationPoint", ShaderUniforms.camera2D_aspect = "camera.aspect", ShaderUniforms.mesh2D_tint = "model.tint", ShaderUniforms.mesh2D_translation = "model.translation", ShaderUniforms.mesh2D_rotation = "model.rotation", ShaderUniforms.mesh2D_rotationPoint = "model.rotationPoint", ShaderUniforms.mesh2D_scale = "model.scale", ShaderUniforms.mesh2D_zIndex = "model.zIndex"; export class Shader { constructor(e, t) { this.program = gl.NONE; let r = Shader.compile(e, gl.VERTEX_SHADER), i = Shader.compile(t, gl.FRAGMENT_SHADER); this.program = gl.createProgram(), gl.attachShader(this.program, r), gl.attachShader(this.program, i), gl.linkProgram(this.program) } static compile(e, t, r = "not provided") { let i = gl.createShader(t); if (gl.shaderSource(i, e), gl.compileShader(i), !gl.getShaderParameter(i, gl.COMPILE_STATUS)) { let e = { type: "SHADER_COMPILE_ERROR", id: r, shaderInt: t, shaderType: t == gl.VERTEX_SHADER ? "vertex shader" : "fragment shader", error: gl.getShaderInfoLog(i) }; return console.log(e), null } return i } use() { gl.useProgram(this.program) } getULoc(e) { return gl.getUniformLocation(this.program, e) } setUInt(e, t) { gl.uniform1i(this.getULoc(e), t) } setUInt2(e, t, r) { gl.uniform2i(this.getULoc(e), t, r) } setUInt3(e, t, r, i) { gl.uniform3i(this.getULoc(e), t, r, i) } setUInt4(e, t, r, i, a) { gl.uniform4i(this.getULoc(e), t, r, i, a) } setUFloat(e, t) { gl.uniform1f(this.getULoc(e), t) } setUFloat2(e, t, r) { gl.uniform2f(this.getULoc(e), t, r) } setUFloat3(e, t, r, i) { gl.uniform3f(this.getULoc(e), t, r, i) } setUFloat4(e, t, r, i, a) { gl.uniform4f(this.getULoc(e), t, r, i, a) } setUMat4(e, t) { gl.uniformMatrix4fv(this.getULoc(e), !1, t.m.flat()) } setUVec2(e, t) { this.setUFloat2(e, t.x, t.y) } setUVec3(e, t) { this.setUFloat3(e, t.x, t.y, t.z) } setUVec4(e, t) { this.setUFloat4(e, t.x, t.y, t.z, t.w) } setUBool(e, t) { this.setUInt(e, t ? 1 : 0) } setUMat2(e, t) { gl.uniformMatrix2fv(this.getULoc(e), !1, t.flatten()) } } class ShaderSourceTypes { constructor() { this.vert = "vertex", this.frag = "fragment" } } export class ShaderSource { constructor(e, t, r, i) { this.params = e, this.source = i, this.type = t, ShaderSource.shaders[r] = this } static shaderWithParams(e, t = {}) { let r = Object.keys(t), i = ShaderSource.shaders[e], a = i.source, n = i.getExpectedParams(); for (let e = 0; e < n.length; e++)if (r.includes(n[e])) { let i = r[r.indexOf(n[e])]; a = a.replace("$" + i.toString() + "$", t[i.toString()].toString()) } else a = a.replace("$" + n[e].toString() + "$", i.params[n[e]].toString()); return a } static getShader(e) { return ShaderSource.shaders[e] } static getAllShaderNames() { return Object.keys(ShaderSource.shaders) } getExpectedParams() { return Object.keys(this.params) } static makeFromFile(e, t, r, i) { return new ShaderSource(e, t, r, Utils.loadFile(i)) } } ShaderSource.types = new ShaderSourceTypes, ShaderSource.shaders = {}; export class Vert3D { constructor(e = new Vec3, t = new Vec2, r = new Vec3(1, 1, 1), i = new Vec3) { this.rgb = new Vec3(1, 1, 1), this.p = e, this.t = t, this.rgb = r, this.n = i } } Vert3D.tSize = 17; export class Vert2D { constructor(e = new Vec2, t = new Vec2) { this.p = e, this.t = t } } Vert2D.tSize = 4; export class Tri3D { constructor(e = [new Vert3D, new Vert3D, new Vert3D]) { this.v = [e[0], e[1], e[2]] } } export class Tri2D { constructor(e = [new Vert2D, new Vert2D, new Vert2D]) { this.v = [e[0], e[1], e[2]] } } export class Material { constructor(e = null, t = null, r = null, i = .5) { this.shininess = .5, this.parallaxScale = 0, this.UVScale = Vec2.filledWith(1), this.diffuseTexture = e, this.specularTexture = t, this.normalTexture = r, this.parallaxTexture = null, this.shininess = i } bindTextures() { gl.activeTexture(gl.TEXTURE0), gl.bindTexture(gl.TEXTURE_2D, this.diffuseTexture), gl.activeTexture(gl.TEXTURE1), gl.bindTexture(gl.TEXTURE_2D, this.specularTexture), gl.activeTexture(gl.TEXTURE2), gl.bindTexture(gl.TEXTURE_2D, this.normalTexture), gl.activeTexture(gl.TEXTURE3), gl.bindTexture(gl.TEXTURE_2D, this.parallaxTexture) } static sendToShader(e) { e.setUInt(ShaderUniforms.material_diffuse, 0), e.setUInt(ShaderUniforms.material_specular, 1), e.setUInt(ShaderUniforms.material_normal, 2), e.setUInt(ShaderUniforms.material_parallax, 3), e.setUInt("screenTexture", 0) } } export class ReferenceMaterial { constructor() { this.diffuseTexture = gl.NONE, this.specularTexture = gl.NONE, this.normalTexture = gl.NONE, this.parallaxTexture = gl.NONE } } export class Position3D { constructor(e = new Vec3, t = new Vec3) { this.position = e, this.rotation = t } } export class Position2D { constructor(e = new Vec2, t = 0) { this.position = e, this.rotation = t } } export class Camera3D extends Position3D { constructor(e = 75, t = .1, r = 500, i = 9 / 16) { super(), this.FOV = e, this.clipNear = t, this.clipFar = r, this.aspect = i } lookVector() { let e = new Vec3(0, 0, 1), t = (new Vec3(0, 1, 0), Mat4.mul(Mat4.mul(Mat4.rotationX(this.rotation.x), Mat4.rotationY(this.rotation.y)), Mat4.rotationZ(this.rotation.z))); return e = Vec3.mulMat(e, t) } perspective() { return Mat4.perspective(this.FOV, this.aspect, this.clipNear, this.clipFar) } cameraMatrix() { let e = new Vec3(0, 1, 0), t = new Vec3(0, 0, 1), r = Mat4.rotationY(this.rotation.y), i = Mat4.rotationX(this.rotation.x), a = Mat4.rotationZ(this.rotation.z), n = Vec3.mulMat(t, Mat4.mul(Mat4.mul(i, r), a)); return t = Vec3.add(this.position, n), Mat4.pointedAt(this.position, t, e) } stdControl(e = 1, t = 1) { let r = Camera3D.stdController(this, this, e, t); this.position = r.position, this.rotation = r.rotation } static stdController(e, t, r = 1, i = 1) { let a = e.lookVector(), n = t, s = new Vec3, l = new Vec3(0, 1, 0), o = new Vec3; return Input.getKeyState("w") && (s = Vec3.add(s, a)), Input.getKeyState("s") && (s = Vec3.mulFloat(Vec3.add(s, a), -1)), Input.getKeyState("d") && (s = Vec3.add(s, Vec3.cross(a, l))), Input.getKeyState("a") && (s = Vec3.add(s, Vec3.mulFloat(Vec3.cross(a, l), -1))), (Input.getKeyState("q") || Input.getKeyState(" ")) && (s.y = s.y + 1), Input.getKeyState("e") && (s.y = s.y - 1), Input.getKeyState("ArrowLeft") && (o.y = -i), Input.getKeyState("ArrowRight") && (o.y = i), Input.getKeyState("ArrowUp") && (o.x = -i), Input.getKeyState("ArrowDown") && (o.x = i), n.rotation = Vec3.add(n.rotation, Vec3.mulFloat(o, Time.deltaTime)), n.position = Vec3.add(n.position, Vec3.mulFloat(Vec3.normalize(s), r * Time.deltaTime)), n.rotation.x >= Rotation.degToRad(87) && (n.rotation.x = Rotation.degToRad(87)), n.rotation.x <= -Rotation.degToRad(87) && (n.rotation.x = -Rotation.degToRad(87)), Math.abs(n.rotation.y) >= Rotation.degToRad(360) && (n.rotation.y = 0), Math.abs(n.rotation.z) >= Rotation.degToRad(360) && (n.rotation.z = 0), n } } export class Camera2D extends Position2D { constructor(e, t = new Vec2, r = 0) { super(t, r), this.rotationPoint = new Vec2, this.aspect = e } cameraMatrix() { return Mat2.rotation(this.rotation) } sendToShader(e) { e.setUMat2("camera.rotation", this.cameraMatrix()), e.setUVec2("camera.translation", this.position), e.setUFloat("camera.aspect", this.aspect), e.setUVec2("camera.rotationPoint", this.rotationPoint) } stdControl(e, t) { let r = new Vec2, i = new Vec2(Math.sin(this.rotation), Math.cos(this.rotation)), a = 0; Input.getKeyState("w") && (r = r.sub(i)), Input.getKeyState("s") && (r = r.add(i)), Input.getKeyState("d") && (r = r.add(new Vec2(Math.sin(this.rotation - 1.5708), Math.cos(this.rotation - 1.5708)))), Input.getKeyState("a") && (r = r.add(new Vec2(Math.sin(this.rotation + 1.5708), Math.cos(this.rotation + 1.5708)))), Input.getKeyState("ArrowLeft") && (a -= t), Input.getKeyState("ArrowRight") && (a += t), this.position = this.position.add(r.normalized().mulFloat(Time.deltaTime * e)), this.rotation = this.rotation + a * Time.deltaTime } } let loadedImages = {}, loadedGeometry = {}, loadedReferenceTextures = {}, loadedReferenceGeometry = {}; export class Mesh3D extends Position3D { constructor(e = new Vec3, t = new Vec3, r = new Vec3, i = new Vec3(1, 1, 1), a = new Material) { super(e, t), this.tint = new Vec3(1, 1, 1), this.triangles = 0, this.useGeometryReferenceCache = !1, this.useTextureReferenceCache = !0, this.renderTransparent = !1, this.rotationCenter = r, this.scale = i, this.material = a, this.loaded = !1, this.mVBO = gl.NONE, this.mVAO = gl.NONE, this.data = [] } make(e, t = "NONE", r = "NONE", i = "NONE", a = "NONE") { if (this.useGeometryReferenceCache && Object.keys(loadedReferenceGeometry).includes(e)) { let t = loadedReferenceGeometry[e]; this.mVBO = t.VBO, this.mVAO = t.VAO, this.triangles = t.triangles, this.loaded = !0 } else if (Object.keys(loadedGeometry).includes(e)) this.loadFromObjData(loadedGeometry[e].data); else { let t = new Geometry(Utils.loadFile(e), "USER_GEOMETRY"); loadedGeometry[e] = t, this.loadFromObjData(t.data) } if (this.setTexture(t, r, i, a), this.load(), !Object.keys(loadedReferenceGeometry).includes(e)) { let t = new ReferenceGeometry; t.VBO = this.mVBO, t.VAO = this.mVAO, t.triangles = this.triangles, loadedReferenceGeometry[e] = t } } loadFromObjData(e) { let t = [], r = [], i = [], a = e.split("\n"), n = e.includes("vn"), s = e.includes("vt"); for (let e = 0; e < a.length; e++) { let l = a[e]; if ("v" == l[0]) if ("t" == l[1]) { let e = new Vec2, t = l.split(" "); e.x = parseFloat(t[1]), e.y = parseFloat(t[2]), i.push(e) } else if ("n" == l[1]) { let e = new Vec3, t = l.split(" "); e.x = parseFloat(t[1]), e.y = parseFloat(t[2]), e.z = parseFloat(t[3]), r.push(e) } else { let e = new Vec3, r = l.split(" "); e.x = parseFloat(r[1]), e.y = parseFloat(r[2]), e.z = parseFloat(r[3]), t.push(e) } if ("f" == l[0]) { let e = 1; n && e++, s && e++; let a = [], o = l.replace("f", "").split(/[\/\s]+/g); for (let e = 1; e < o.length; e++)a.push(parseInt(o[e])); let m = new Tri3D; for (let l = 0; l < 3; l++)m.v[l].p = t[a[e * l] - 1], s && (m.v[l].t = i[a[e * l + 1] - 1]), n && !s && (m.v[l].n = r[a[e * l + 1] - 1]), n && s && (m.v[l].n = r[a[e * l + 2] - 1]); this.addTriangle(m) } } } addTriangle(e) { let t = Mesh3D.calcTangents(e); for (let r = 0; r < 3; r++)this.data.push(e.v[r].p.x), this.data.push(e.v[r].p.y), this.data.push(e.v[r].p.z), this.data.push(e.v[r].p.w), this.data.push(e.v[r].t.x), this.data.push(e.v[r].t.y), this.data.push(e.v[r].t.w), this.data.push(e.v[r].rgb.x), this.data.push(e.v[r].rgb.y), this.data.push(e.v[r].rgb.z), this.data.push(e.v[r].rgb.w), this.data.push(e.v[r].n.x), this.data.push(e.v[r].n.y), this.data.push(e.v[r].n.z), this.data.push(t[r].x), this.data.push(t[r].y), this.data.push(t[r].z); this.triangles++ } static createTextureFromImage(e, t = gl.TEXTURE0, r = [gl.REPEAT, gl.REPEAT], i = gl.LINEAR_MIPMAP_LINEAR, a = gl.LINEAR) { let n = gl.NONE; return n = gl.createTexture(), gl.activeTexture(t), gl.bindTexture(gl.TEXTURE_2D, n), gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(Mesh3D.defaultColour)), e.complete ? (gl.activeTexture(t), gl.bindTexture(gl.TEXTURE_2D, n), gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, e), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, r[0]), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, r[1]), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, i), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, a), gl.generateMipmap(gl.TEXTURE_2D)) : e.addEventListener("load", function () { gl.activeTexture(t), gl.bindTexture(gl.TEXTURE_2D, n), gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, e), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, r[0]), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, r[1]), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, i), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, a), gl.generateMipmap(gl.TEXTURE_2D) }), n } static createTextureFromRGBAPixelArray(e, t, r, i = gl.TEXTURE0, a = [gl.REPEAT, gl.REPEAT], n = gl.LINEAR_MIPMAP_LINEAR, s = gl.LINEAR) { let l = gl.createTexture(); return gl.activeTexture(i), gl.bindTexture(gl.TEXTURE_2D, l), gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, t, r, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(e)), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, a[0]), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, a[1]), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, n), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, s), gl.generateMipmap(gl.TEXTURE_2D), l } static createTextureFromRGBPixelArray(e, t, r, i = gl.TEXTURE0, a = [gl.REPEAT, gl.REPEAT], n = gl.LINEAR_MIPMAP_LINEAR, s = gl.LINEAR) { let l = gl.createTexture(); return gl.activeTexture(i), gl.bindTexture(gl.TEXTURE_2D, l), gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, t, r, 0, gl.RGB, gl.UNSIGNED_BYTE, new Uint8Array(e)), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, a[0]), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, a[1]), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, n), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, s), gl.generateMipmap(gl.TEXTURE_2D), l } static createColorTexture(e, t = 1, r = gl.TEXTURE0, i = [gl.REPEAT, gl.REPEAT], a = gl.LINEAR_MIPMAP_LINEAR, n = gl.LINEAR) { let s = (16711680 & e) >> 16, l = (65280 & e) >> 8, o = 255 & e; return Mesh3D.createTextureFromRGBAPixelArray([s, l, o, 255 * t], 1, 1, r, i, a, n) } static createTextureFromPath(e, t = gl.TEXTURE0, r, i = [gl.REPEAT, gl.REPEAT], a = gl.LINEAR_MIPMAP_LINEAR, n = gl.LINEAR) { if (r && Object.keys(loadedReferenceTextures).includes(e)) return loadedReferenceTextures[e]; let s = gl.NONE; if (s = gl.createTexture(), gl.activeTexture(t), gl.bindTexture(gl.TEXTURE_2D, s), gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(Mesh3D.defaultColour)), "NONE" != e) { let r; Object.keys(loadedImages).includes(e) && loadedImages[e].complete ? (r = loadedImages[e], gl.activeTexture(t), gl.bindTexture(gl.TEXTURE_2D, s), gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, r), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, i[0]), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, i[1]), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, a), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, n), gl.generateMipmap(gl.TEXTURE_2D)) : ((r = new Image).src = e, r.crossOrigin = "anonymous", loadedImages[e] = r, r.addEventListener("load", function () { gl.activeTexture(t), gl.bindTexture(gl.TEXTURE_2D, s), gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, r), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, i[0]), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, i[1]), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, a), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, n), gl.generateMipmap(gl.TEXTURE_2D) })) } return Object.keys(loadedReferenceTextures).includes(e) ? s : loadedReferenceTextures[e] = s } setTexture(e, t = "NONE", r = "NONE", i = "NONE") { this.material.diffuseTexture = Mesh3D.createTextureFromPath(e, gl.TEXTURE0, this.useTextureReferenceCache), this.material.specularTexture = Mesh3D.createTextureFromPath(t, gl.TEXTURE1, this.useTextureReferenceCache), this.material.normalTexture = Mesh3D.createTextureFromPath(r, gl.TEXTURE2, this.useTextureReferenceCache), this.material.parallaxTexture = Mesh3D.createTextureFromPath(i, gl.TEXTURE3, this.useTextureReferenceCache) } modelMatrix() { let e = Mat4.rotationOnPoint(this.rotation, this.rotationCenter), t = Mat4.translation(this.position.x, this.position.y, this.position.z), r = Mat4.scale(this.scale.x, this.scale.y, this.scale.z); return Mat4.mul(Mat4.mul(r, e), t) } load(e = gl.DYNAMIC_DRAW) { if (!this.loaded) { this.mVBO = gl.createBuffer(), gl.bindBuffer(gl.ARRAY_BUFFER, this.mVBO), gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.data), e), this.mVAO = gl.createVertexArray(), gl.bindVertexArray(this.mVAO), gl.bindBuffer(gl.ARRAY_BUFFER, this.mVBO); let t = 4, r = Vert3D.tSize * t; gl.vertexAttribPointer(0, 4, gl.FLOAT, !1, r, 0), gl.enableVertexAttribArray(0), gl.vertexAttribPointer(1, 3, gl.FLOAT, !1, r, 4 * t), gl.enableVertexAttribArray(1), gl.vertexAttribPointer(2, 4, gl.FLOAT, !1, r, 7 * t), gl.enableVertexAttribArray(2), gl.vertexAttribPointer(3, 4, gl.FLOAT, !1, r, 11 * t), gl.enableVertexAttribArray(3), gl.vertexAttribPointer(4, 3, gl.FLOAT, !1, r, 14 * t), gl.enableVertexAttribArray(4), gl.bindBuffer(gl.ARRAY_BUFFER, null), this.loaded = !0 } } static calcTangents(e) { let t = e.v[0].p, r = e.v[1].p, i = e.v[2].p, a = e.v[0].t, n = e.v[1].t, s = e.v[2].t, l = r.x - t.x, o = i.x - t.x, m = r.y - t.y, c = i.y - t.y, h = r.z - t.z, g = i.z - t.z, d = n.x - a.x, u = s.x - a.x, T = n.y - a.y, E = s.y - a.y, p = 1 / (d * E - u * T), x = new Vec3((E * l - T * o) * p, (E * m - T * c) * p, (E * h - T * g) * p), R = new Vec3((d * o - u * l) * p, (d * c - u * m) * p, (d * g - u * h) * p), U = [x, x, x]; for (var f = 0; f < 3; f++) { let t = U[f], r = e.v[f].n; (t = t.sub(r).mulFloat(Vec3.dot(r, t)).normalized()).w = Vec3.dot(Vec3.cross(r, t), R) < 0 ? -1 : 1 } return U } static renderAll(e, t, r, i, a = []) { e.use(), Material.sendToShader(e), e.setUFloat(ShaderUniforms.ingenium_time, (Date.now() - IngeniumWeb.startTime) / 1e3), e.setUMat4(ShaderUniforms.camera3D_view, Mat4.inverse(t.cameraMatrix())), e.setUMat4(ShaderUniforms.camera3D_projection, t.perspective()), e.setUVec3(ShaderUniforms.camera3D_viewPos, t.position), e.setUInt(ShaderUniforms.shader_numLights, a.length), i.sendToShader(e); for (let t = 0; t < a.length; t++)a[t].sendToShader(e, t); let n = []; for (let t = 0; t < r.length; t++)1 != r[t].tint.w || r[t].renderTransparent ? n.push(r[t]) : Mesh3D.renderMeshRaw(r[t], e); n.sort(function (e, r) { let i = t.position.sub(e.position).len(), a = t.position.sub(r.position).len(); return i < a ? 1 : i > a ? -1 : 0 }); for (let t = 0; t < n.length; t++)Mesh3D.renderMeshRaw(n[t], e) } static renderMeshRaw(e, t) { gl.bindVertexArray(e.mVAO); let r = e.modelMatrix(); t.setUMat4(ShaderUniforms.mesh3D_modelMatrix, r), t.setUMat4(ShaderUniforms.mesh3D_invModelMatrix, Mat4.inverse(r)), t.setUVec4(ShaderUniforms.mesh3D_tint, e.tint), t.setUFloat(ShaderUniforms.material_shininess, e.material.shininess), t.setUFloat(ShaderUniforms.material_heightScale, e.material.parallaxScale), t.setUVec2(ShaderUniforms.material_scaleUV, e.material.UVScale), e.material.bindTextures(); let i = 3 * e.triangles; gl.drawArrays(gl.TRIANGLES, 0, i) } } Mesh3D.defaultColour = [128, 128, 255, 255]; export class Mesh2D extends Position2D { constructor(e = new Vec2, t = 0, r = Vec2.filledWith(1), i = new Vec2, a = new Material) { super(e, t), this.tint = new Vec3(1, 1, 1), this.triangles = 0, this.useGeometryReferenceCache = !1, this.useTextureReferenceCache = !0, this.renderTransparent = !1, this.zIndex = 0, this.scale = r, this.rotationCenter = i, this.material = a } load(e = gl.STATIC_DRAW) { if (!this.loaded) { this.mVBO = gl.createBuffer(), gl.bindBuffer(gl.ARRAY_BUFFER, this.mVBO), gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.data), e), this.mVAO = gl.createVertexArray(), gl.bindVertexArray(this.mVAO), gl.bindBuffer(gl.ARRAY_BUFFER, this.mVBO); let t = 4, r = Vert2D.tSize * t; gl.vertexAttribPointer(0, 2, gl.FLOAT, !1, r, 0), gl.enableVertexAttribArray(0), gl.vertexAttribPointer(1, 2, gl.FLOAT, !1, r, 2 * t), gl.enableVertexAttribArray(1), this.loaded = !0 } } modelMatrix() { return Mat2.rotation(this.rotation) } sendToShader(e) { e.setUVec4("model.tint", this.tint), e.setUVec2("model.translation", this.position), e.setUMat2("model.rotation", this.modelMatrix()), e.setUVec2("model.rotationPoint", this.rotationCenter), e.setUVec2("model.scale", this.scale), e.setUFloat("model.zIndex", this.zIndex), gl.activeTexture(gl.TEXTURE0), gl.bindTexture(gl.TEXTURE_2D, this.material.diffuseTexture) } bindVBO() { gl.bindBuffer(gl.ARRAY_BUFFER, this.mVBO) } bindVAO() { gl.bindVertexArray(this.mVAO) } static renderAll(e, t, r) { e.use(), Material.sendToShader(e), t.sendToShader(e), e.setUFloat("u_time", Date.now()); for (let i = 0; i < r.length; i++)r[i].bindVAO(), e.setUVec2("translation", r[i].position.add(t.position)), r[i].sendToShader(e), gl.drawArrays(gl.TRIANGLES, 0, 3 * r[i].triangles) } } Mesh2D.renderTranslationName = "translation"; export class Light { constructor(e, t, r, i) { this.ambient = e, this.diffuse = t, this.specular = r, this.intensity = i } } export class PointLight extends Light { constructor(e = new Vec3(.05, .05, .05), t = new Vec3(.8, .8, .8), r = new Vec3(.2, .2, .2), i = new Vec3, a = 1) { super(e, t, r, a), this.constant = 1, this.linear = .09, this.quadratic = .032, this.position = i } sendToShader(e, t) { e.setUVec3(ShaderUniforms.pointLight_structName + "[" + t + "]." + ShaderUniforms.pointLight_position, this.position), e.setUVec3(ShaderUniforms.pointLight_structName + "[" + t + "]." + ShaderUniforms.pointLight_ambient, this.ambient), e.setUVec3(ShaderUniforms.pointLight_structName + "[" + t + "]." + ShaderUniforms.pointLight_diffuse, Vec3.mulFloat(this.diffuse, this.intensity)), e.setUVec3(ShaderUniforms.pointLight_structName + "[" + t + "]." + ShaderUniforms.pointLight_specular, Vec3.mulFloat(this.specular, this.intensity)), e.setUFloat(ShaderUniforms.pointLight_structName + "[" + t + "]." + ShaderUniforms.pointLight_constant, this.constant), e.setUFloat(ShaderUniforms.pointLight_structName + "[" + t + "]." + ShaderUniforms.pointLight_linear, this.linear), e.setUFloat(ShaderUniforms.pointLight_structName + "[" + t + "]." + ShaderUniforms.pointLight_quadratic, this.quadratic) } } export class DirectionalLight extends Light { constructor(e = new Vec3(.05, .05, .05), t = new Vec3(.8, .8, .8), r = new Vec3(.2, .2, .2), i = new Vec3(0, -1, .2), a = 1) { super(e, t, r, a), this.direction = i } sendToShader(e) { e.setUVec3(ShaderUniforms.directionalLight_direction, this.direction), e.setUVec3(ShaderUniforms.directionalLight_ambient, this.ambient), e.setUVec3(ShaderUniforms.directionalLight_specular, this.specular.mulFloat(this.intensity)), e.setUVec3(ShaderUniforms.directionalLight_diffuse, this.diffuse.mulFloat(this.intensity)) } } export class Geometry { constructor(e, t = "NONE") { this.data = e, this.name = t } static makeCube() { return new Geometry(cubeData, "Default Cube") } } Geometry.quadData = [-1, 1, 0, 1, -1, -1, 0, 0, 1, 1, 1, 1, -1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1], Geometry.triData = [0, 1, .5, 1, -1, -1, 0, 0, 1, -1, 1, 0]; export class ReferenceGeometry { } let cubeData = "v -1.000000 1.000000 -1.000000\nv 1.000000 1.000000 1.000000\nv 1.000000 1.000000 -1.000000\nv -1.000000 -1.000000 1.000000\nv 1.000000 -1.000000 1.000000\nv -1.000000 1.000000 1.000000\nv -1.000000 -1.000000 -1.000000\nv 1.000000 -1.000000 -1.000000\nvt 1.000000 0.000000\nvt 0.666667 0.333333\nvt 0.666667 0.000000\nvt 0.333333 0.333333\nvt 0.000000 0.000000\nvt 0.333333 0.000000\nvt 0.333333 0.666667\nvt 0.000000 0.333333\nvt 0.333333 0.333333\nvt 0.666667 0.000000\nvt 0.333333 0.000000\nvt 0.666667 0.666667\nvt 0.333333 0.333333\nvt 0.666667 0.333333\nvt 0.333333 1.000000\nvt 0.000000 0.666667\nvt 0.333333 0.666667\nvt 1.000000 0.333333\nvt 0.000000 0.333333\nvt 0.000000 0.666667\nvt 0.666667 0.333333\nvt 0.333333 0.666667\nvt 0.000000 1.000000\nvn 0.0000 1.0000 0.0000\nvn 0.0000 -0.0000 1.0000\nvn -1.0000 0.0000 0.0000\nvn 0.0000 -1.0000 -0.0000\nvn 1.0000 0.0000 0.0000\nvn 0.0000 0.0000 -1.0000\ns off\nf 1/1/1 2/2/1 3/3/1\nf 2/4/2 4/5/2 5/6/2\nf 6/7/3 7/8/3 4/9/3\nf 8/10/4 4/9/4 7/11/4\nf 3/12/5 5/13/5 8/14/5\nf 1/15/6 8/16/6 7/17/6\nf 1/1/1 6/18/1 2/2/1\nf 2/4/2 6/19/2 4/5/2\nf 6/7/3 1/20/3 7/8/3\nf 8/10/4 5/21/4 4/9/4\nf 3/12/5 2/22/5 5/13/5\nf 1/15/6 3/23/6 8/16/6"; export class Utils { static loadFile(e) { let t = null, r = new XMLHttpRequest; return r.open("GET", e, !1), r.send(), 200 == r.status ? t = r.responseText : console.error("XMLHTTP error (", e, "): ", r.status), t } } export class FrameBuffer { constructor() { this.properties = {}, this.FBO = gl.createFramebuffer(), this.RBO = gl.createRenderbuffer(), this.type = gl.FRAMEBUFFER } bind() { gl.bindFramebuffer(this.type, this.FBO), gl.bindRenderbuffer(gl.RENDERBUFFER, this.RBO) } addTexture(e, t, r, i = gl.TEXTURE0, a = gl.LINEAR, n = gl.LINEAR) { gl.activeTexture(i), this.bind(); let s = gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D, s), gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, t, r, 0, gl.RGBA, gl.UNSIGNED_BYTE, null), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, a), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, n), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE), this.properties[e] = s, gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, s, 0) } static bindDefault() { gl.bindFramebuffer(gl.FRAMEBUFFER, null) } static createRenderTexture(e, t) { let r = new FrameBuffer; return r.bind(), r.properties.width = e, r.properties.height = t, r.properties.texture = null, gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH24_STENCIL8, r.properties.width, r.properties.height), gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, r.RBO), r.addTexture("texture", r.properties.width, r.properties.height), gl.bindRenderbuffer(gl.RENDERBUFFER, null), r } static renderToRenderTexture(e, t) { e.bind(), IngeniumWeb.window.clear(), gl.viewport(0, 0, e.properties.width, e.properties.height), t() } static setDefaultRenderBuffer() { FrameBuffer.bindDefault(), IngeniumWeb.window.clear(), gl.viewport(0, 0, IngeniumWeb.window.width, IngeniumWeb.window.height) } } FrameBuffer.buffers = [];

        let shaders = {};
        let camera3D = new Camera3D(70, 0.01, 2000);
        let d = new DirectionalLight();
        let p = [new PointLight(new Vec3(0.01, 0.01, 0.01), new Vec3(1, 1, 1), new Vec3(1, 1, 1), new Vec3(0, 0, -3))];
        let m = [];
        function onGlobalCreate() {
            IngeniumWeb.createWindow(16, 9, "Demo");
            IngeniumWeb.defaultSetup();
            IngeniumWeb.window.setClearColour(0xdadada, 255);

            let gParams = {
                version: "300 es",
                normalMap: 0,
                parallaxMap: 0
            };
            new ShaderSource(Object.assign(gParams, {
                precision: "mediump",
                vertexRGB: 0
            }), ShaderSource.types.vert, "defVert", `#version $version$

#ifdef GL_ES
precision $precision$ float;
#endif

#define NORMAL_MAP $normalMap$
#define PARALLAX_MAP $parallaxMap$
#define VERTEX_RGB $vertexRGB$

layout (location = 0) in vec4 vertexPosition;
layout (location = 1) in vec3 vertexUV;
layout (location = 2) in vec4 vertexRGB;
layout (location = 3) in vec3 vertexNormal;

#if NORMAL_MAP || PARALLAX_MAP
layout (location = 4) in vec3 vertexTangent;
#endif

struct Camera {
    mat4 projection;
    mat4 view;
};
struct Mesh {
    mat4 transform;
    mat4 inverseTransform;
    vec4 tint;
    vec2 scaleUV;
};

uniform Mesh mesh;
uniform Camera camera;

out vec2 UV;
out vec4 tint;
out vec3 normal;
out vec3 fragPos;
out mat3 TBN;

mat3 getTBN (vec3 norm, vec3 tangentTheta) {
    norm = normalize(norm);
    vec3 tangent = normalize(tangentTheta);
    tangent = normalize(tangent - dot(tangent, norm) * norm);
    vec3 bitangent = cross(tangent, norm);
    return mat3(tangent, bitangent, norm);
}

void main () {
    vec4 transformed = camera.projection * camera.view * mesh.transform * vertexPosition;
    transformed.x = -transformed.x;
    gl_Position = transformed;
    UV = vertexUV.xy * mesh.scaleUV;
#if VERTEX_RGB
    tint = vertexRGB * mesh.tint;
#else
    tint = mesh.tint;
#endif
    normal = mat3(transpose(mesh.inverseTransform)) * vertexNormal;
    fragPos = vec3(mesh.transform * vertexPosition);

#if NORMAL_MAP || PARALLAX_MAP
    vec3 tangentTheta = (mesh.transform * vec4(vertexTangent, 0.0)).xyz;   
    TBN = getTBN(normal, tangentTheta);
#endif
}`);
            new ShaderSource(Object.assign(gParams, {
                precision: "lowp",
                maxPointLights: 1,
                lightModel: "BLINN",
                parallaxClipEdge: 0,
                parallaxInvert: 1
            }), ShaderSource.types.frag, "defFrag", `#version $version$

#ifdef GL_ES
precision $precision$ float;
#endif

#define $lightModel$ 1
#define NORMAL_MAP $normalMap$
#define PARALLAX_MAP $parallaxMap$
#define PARALLAX_CLIP_EDGE $parallaxClipEdge$
#define PARALLAX_INVERT $parallaxInvert$
#define MAX_POINT_LIGHTS $maxPointLights$

layout (location = 0) out vec4 color;

struct Material {
    sampler2D diffuse;
    sampler2D specular;
    sampler2D normal;
    sampler2D parallax;
    float heightScale;
    float shininess;
};
struct DirLight {
    vec3 direction;
  
    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
};  
struct PointLight {    
    vec3 position;
    
    float constant;
    float linear;
    float quadratic;  
    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
};  

uniform float u_time;
uniform Material material;
uniform DirLight dirLight;
uniform vec3 viewPos;
uniform int numlights;

#if (MAX_POINT_LIGHTS > 0)
uniform PointLight pointLights[MAX_POINT_LIGHTS];
#endif

in vec2 UV;
in vec4 tint;
in vec3 normal;
in vec3 fragPos;

#if PARALLAX_MAP || NORMAL_MAP
in mat3 TBN;
#endif

#if NORMAL_MAP
vec3 CalcBumpedNormal(vec2 cUV)
{
    vec3 BumpMapNormal = texture(material.normal, cUV).xyz;
    BumpMapNormal = 2.0 * BumpMapNormal - vec3(1.0, 1.0, 1.0);
    vec3 NewNormal = TBN * BumpMapNormal;
    NewNormal = normalize(NewNormal);
    return NewNormal;
}
#endif // NORMAL_MAP

#if !defined(NONE)
vec4 CalcDirLight(DirLight light, vec3 cnormal, vec3 viewDir, vec2 coordUV)
{
    vec3 lightDir = normalize(-light.direction);
    float diff = max(dot(cnormal, lightDir), 0.0);
    vec3 reflectDir = reflect(-lightDir, cnormal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);
    vec4 ambient  = vec4(light.ambient, 1.0)  * (texture(material.diffuse, coordUV).rgba * tint.rgba);
    vec4 diffuse  = vec4(light.diffuse  * diff, 1.0) * (texture((material.diffuse), coordUV).rgba * tint.rgba);
    vec4 specular = vec4(light.specular * spec, 1.0) * (texture(material.specular, coordUV).rgba * tint.rgba);
    return vec4(ambient.rgb + diffuse.rgb + specular.rgb, (ambient.a + diffuse.a + specular.a) * 0.333);
} 

vec4 CalcPointLight(PointLight light, vec3 cnormal, vec3 cfragPos, vec3 viewDir, vec2 coordUV)
{
    vec3 lightDir = normalize(light.position - cfragPos);
    float diff = max(dot(cnormal, lightDir), 0.0);
    #if defined(PHONG)  
    vec3 reflectDir = reflect(-lightDir, cnormal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);
    #endif // defined(PHONG)
    #if defined(BLINN)
    vec3 halfwayDir = normalize(lightDir + viewDir);
    float spec = pow(max(dot(normal, halfwayDir), 0.0), material.shininess);
    #endif // defined(BLINN)
    float distance    = length(light.position - cfragPos);
    float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));    
    vec4 ambient  = vec4(light.ambient, 1.0)  * texture(material.diffuse, coordUV).rgba * tint.rgba;
    vec4 diffuse  = vec4(light.diffuse * diff, 1.0) * texture(material.diffuse, coordUV).rgba * tint.rgba;
    vec4 specular = vec4(light.specular * spec, 1.0) * texture(material.specular, coordUV).rgba * tint.rgba;
    ambient  *= attenuation;
    diffuse  *= attenuation;
    specular *= attenuation;
    return vec4(ambient.rgb + diffuse.rgb + specular.rgb, (ambient.a * diffuse.a * specular.a) * 0.333);
}
#endif // !defined(NONE)

#if PARALLAX_MAP
vec2 ParallaxMapping(vec2 texCoords, vec3 viewDir)
{ 
    const float minLayers = 8.0;
    const float maxLayers = 32.0;
    float numLayers = mix(maxLayers, minLayers, abs(dot(normal, viewDir)));  
    float layerDepth = 1.0 / numLayers;
    float currentLayerDepth = 0.0;
    vec2 P = viewDir.xy / viewDir.z * material.heightScale; 
    // vec2 P = viewDir.xy * material.heightScale;
    vec2 deltaTexCoords = P / numLayers;
  
    vec2  currentTexCoords     = texCoords;
    #if PARALLAX_INVERT
    float currentDepthMapValue = 1.0 - texture(material.parallax, currentTexCoords).r;
    #else
    float currentDepthMapValue = texture(material.parallax, currentTexCoords).r;
    #endif
      
    while(currentLayerDepth < currentDepthMapValue)
    {
        currentTexCoords -= deltaTexCoords;
    #if PARALLAX_INVERT
        currentDepthMapValue = 1.0 - texture(material.parallax, currentTexCoords).r; 
    #else
        currentDepthMapValue = texture(material.parallax, currentTexCoords).r; 
    #endif 
        currentLayerDepth += layerDepth;  
    }
    
    vec2 prevTexCoords = currentTexCoords + deltaTexCoords;

    float afterDepth  = currentDepthMapValue - currentLayerDepth;
    #if PARALLAX_INVERT
    float beforeDepth = 1.0 - texture(material.parallax, prevTexCoords).r - currentLayerDepth + layerDepth;
    #else
    float beforeDepth = texture(material.parallax, prevTexCoords).r - currentLayerDepth + layerDepth;
    #endif // PARALLAX_INVERT
    float weight = afterDepth / (afterDepth - beforeDepth);
    vec2 finalTexCoords = prevTexCoords * weight + currentTexCoords * (1.0 - weight);

    return finalTexCoords;
}
#endif // PARALLAX_MAP

void main () 
{
    vec2 cUV = UV;
    vec3 viewDir = normalize(viewPos - fragPos);
#if PARALLAX_MAP
    vec3 tangentViewDir = normalize(TBN * viewDir);
    cUV = ParallaxMapping(cUV, tangentViewDir);
    #if PARALLAX_CLIP_EDGE
    if(cUV.x > 1.0 || cUV.y > 1.0 || cUV.x < 0.0 || cUV.y < 0.0)
        discard;
    #endif
#endif

#if NORMAL_MAP
    vec3 norm = CalcBumpedNormal(cUV);
#else
    vec3 norm = normalize(normal);
#endif
#if PARALLAX_MAP
    vec4 result = CalcDirLight(dirLight, norm, tangentViewDir, cUV);
#else
    #if !defined(NONE)
    vec4 result = CalcDirLight(dirLight, norm, viewDir, cUV);
    #else
    vec4 result = texture(material.diffuse, cUV).rgba * tint.rgba;
    #endif
#endif
#if !defined(NONE)
    #if MAX_POINT_LIGHTS > 0
    for(int i = 0; i < numlights; i++) {
        #if PARALLAX_MAP
        result += CalcPointLight(pointLights[i], norm, fragPos, tangentViewDir, cUV);
        #else
        result += CalcPointLight(pointLights[i], norm, fragPos, viewDir, cUV);
        #endif
    }
    result.a /= float(numlights);
    #endif
#endif
    color = result;
}`);

            shaders.asn = new Shader(ShaderSource.shaderWithParams("defVert"),
                ShaderSource.shaderWithParams("defFrag"));

            Time.setFPS(30);
            Time.setFixedFPS(5);

            m.push(new Mesh3D(new Vec3(0, 0, 1)));
            m[0].loadFromObjData(Geometry.makeCube().data);
            m[0].setTexture();
            m[0].material.diffuseTexture = Mesh3D.createColorTexture(0x101010);
            m[0].material.specularTexture = Mesh3D.createColorTexture(0xffffff);
            m[0].load();
            m[0].scale = new Vec3(0.3, 0.3, 0.3);
        }
        function onUpdate() {
            camera3D.stdControl(1, PI);
            m[0].rotation = m[0].rotation.add(new Vec3(1, 1, 1).mulFloat(Time.deltaTime));
            Mesh3D.renderAll(shaders.asn, camera3D, m, d, p);
        }
        let scene = new Scene(function () { }, onUpdate);
        IngeniumWeb.start([scene], onGlobalCreate);
    </script>
</body>

</html>