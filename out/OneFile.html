<!doctype html>
<html>

<head>
    <title>Ingenium Web</title>
</head>

<body style="height: 100%; width: 100%; margin : 0; overflow : hidden;">
    <div id="root" style="margin: 0; background-color: whitesmoke; position: absolute;"></div>
    <script type="module">
        "use strict"; export let gl; export class Input { static setup() { window.addEventListener("keydown", e => { Input.keys[e.key] = !0 }, !0), window.addEventListener("keyup", e => { Input.keys[e.key] = !1 }, !0) } static getKeyState(e) { return Input.keys[e] } } Input.keys = {}; export class Time { static setFPS(e) { e <= 0 && IngeniumWeb.terminate("Error: FPS cannot be less than or equal to 0."), Time.targetDeltaTime = 1e3 / e } static setFixedFPS(e) { e <= 0 && IngeniumWeb.terminate("Error: FPS cannot be less than or equal to 0."), Time.targetFixedDeltaTime = 1e3 / e } static updateDeltaTime() { Time.deltaTime = (Date.now() - Time.lastFrame) / 1e3, Time.lastFrame = Date.now() } static updateFixedDeltaTime() { Time.fixedDeltaTime = (Date.now() - Time.lastFixedFrame) / 1e3, Time.lastFixedFrame = Date.now() } static nextFixedFrameReady() { return Date.now() - Time.lastFixedFrame >= Time.targetFixedDeltaTime && (Time.updateFixedDeltaTime(), !0) } static nextFrameReady() { return Date.now() - Time.lastFrame >= Time.targetDeltaTime && (Time.updateDeltaTime(), !0) } static deltaTimeToFPS(e) { return 1 / e } } Time.deltaTime = .1, Time.fixedDeltaTime = .1, Time.targetDeltaTime = 1e3 / 45, Time.targetFixedDeltaTime = 1e3 / 35, Time.lastFrame = Date.now(), Time.lastFixedFrame = Date.now(); export class WebGLWindow { constructor(e, t, r, i) { this.takeUpAsepct = !0, this.parent = document.getElementById(r), this.canvas = document.createElement("canvas"), this.canvas.setAttribute("width", e.toString() + "px"), this.canvas.setAttribute("height", t.toString() + "px"), this.canvas.setAttribute("id", i), this.parent.appendChild(this.canvas), this.width = e, this.height = t, this.aspectRatio = t / e, this.setGL() } sizeToWindow(e) { e = 1 / e; let t = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0), r = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0); t / r != e && (r * e < t ? (this.canvas.width = r * e, this.canvas.height = r, this.canvas.style.setProperty("height", this.canvas.height + "px"), this.canvas.style.setProperty("width", this.canvas.width.toString() + "px")) : r * e > t && (this.canvas.width = t, this.canvas.height = t / e, this.canvas.style.setProperty("width", this.canvas.width + "px"), this.canvas.style.setProperty("height", this.canvas.height.toString() + "px")), this.width = this.canvas.width, this.height = this.canvas.height, FrameBuffer.bindDefault(), gl.viewport(0, 0, gl.canvas.width, gl.canvas.height)) } setGL() { (gl = this.canvas.getContext(IngeniumWeb.glVersion)) || console.error("Selected WebGL version (" + IngeniumWeb.glVersion + ") may not be supported.") } setClearColour(e, t) { gl.clearDepth(1); let r = (16711680 & e) >> 16, i = (65280 & e) >> 8, a = 255 & e; gl.clearColor(r / 255, i / 255, a / 255, t); let n = { prop: "background", val: "rgb(" + r.toString() + "," + i.toString() + "," + a.toString() + ")" }; this.parent.style.setProperty(n.prop, n.val), document.body.style.setProperty(n.prop, n.val) } clear() { gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT) } } export class Scene { constructor(e = function () { }, t = function () { }, r = function () { }, i = function () { }) { this.onCreate = e, this.onClose = r, this.onUpdate = t, this.onFixedUpdate = i } } export class IngeniumWeb { static start(e, t = function () { }, r = function () { }, i = function () { }, a = function () { }, n = "webgl2") { this.startTime = Date.now(), IngeniumWeb.window = null, IngeniumWeb.running = !0, IngeniumWeb.scenes = e, IngeniumWeb.onCreate = t, IngeniumWeb.onUpdate = r, IngeniumWeb.onClose = i, IngeniumWeb.onFixedUpdate = a, IngeniumWeb.glVersion = n, Input.setup(), IngeniumWeb.init() } static defaultInit() { IngeniumWeb.createWindow(16, 9, "Ingenium Web"), IngeniumWeb.defaultGLSetup(), IngeniumWeb.window.setClearColour(3158064, 1), Time.setFPS(40), Time.setFixedFPS(5) } static createWindow(e, t, r, i = "root", a = !0) { IngeniumWeb.window = new WebGLWindow(e, t, i, r), IngeniumWeb.window.takeUpAsepct = a, a && window.addEventListener("resize", function () { IngeniumWeb.window.sizeToWindow(IngeniumWeb.window.aspectRatio) }) } static update() { Time.updateDeltaTime(), IngeniumWeb.onUpdate(), IngeniumWeb.scenes[IngeniumWeb.currentScene] && IngeniumWeb.scenes[IngeniumWeb.currentScene].onUpdate() } static fixedUpdate() { Time.updateFixedDeltaTime(), IngeniumWeb.onFixedUpdate(), IngeniumWeb.scenes[IngeniumWeb.currentScene] && IngeniumWeb.scenes[IngeniumWeb.currentScene].onFixedUpdate(), IngeniumWeb.running || (IngeniumWeb.scenes[IngeniumWeb.currentScene] && IngeniumWeb.scenes[IngeniumWeb.currentScene].onClose(), IngeniumWeb.onClose(), clearInterval(IngeniumWeb.intervalCode), clearInterval(IngeniumWeb.fixedIntervalCode)) } static init() { Time.updateDeltaTime(), Time.updateFixedDeltaTime(), IngeniumWeb.onCreate(), IngeniumWeb.scenes[IngeniumWeb.currentScene] && IngeniumWeb.scenes[IngeniumWeb.currentScene].onCreate(), IngeniumWeb.refreshLoops(), IngeniumWeb.window.takeUpAsepct && IngeniumWeb.window.sizeToWindow(IngeniumWeb.window.aspectRatio) } static refreshLoops() { clearInterval(IngeniumWeb.intervalCode), clearInterval(IngeniumWeb.fixedIntervalCode), IngeniumWeb.intervalCode = setInterval(IngeniumWeb.update, Time.targetDeltaTime), IngeniumWeb.fixedIntervalCode = setInterval(IngeniumWeb.fixedUpdate, Time.targetFixedDeltaTime) } static terminate(e) { console.error("Fatal: " + e), IngeniumWeb.running = !1, clearInterval(IngeniumWeb.intervalCode), clearInterval(IngeniumWeb.fixedIntervalCode) } static enterScene(e) { IngeniumWeb.currentScene = e, IngeniumWeb.scenes[IngeniumWeb.currentScene] && IngeniumWeb.scenes[IngeniumWeb.currentScene].onCreate() } static defaultGLSetup() { gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA), gl.enable(gl.BLEND), gl.enable(gl.DEPTH_TEST), gl.depthMask(!0), gl.depthFunc(gl.LEQUAL), gl.depthRange(0, 1) } } IngeniumWeb.scenes = [], IngeniumWeb.currentScene = 0, IngeniumWeb.startTime = 0; export let PI = 355 / 113; export class Vec2 { constructor(e = 0, t = 0, r = 1) { this.x = 0, this.y = 0, this.w = 1, this.x = e, this.y = t, this.w = r } static filledWith(e) { return new Vec2(e, e) } static sub(e, t) { return new Vec2(e.x - t.x, e.y - t.y) } static add(e, t) { return new Vec2(e.x + t.x, e.y + t.y) } static mul(e, t) { return new Vec2(e.x * t.x, e.y * t.y) } static div(e, t) { return new Vec2(e.x / t.x, e.y / t.y) } static mulFloat(e, t) { return new Vec2(e.x * t, e.y * t) } static divFloat(e, t) { return new Vec2(e.x / t, e.y / t) } static len(e) { return Math.sqrt(e.x * e.x + e.y * e.y) } static normalize(e) { let t = Vec2.len(e); return new Vec2(e.x / t, e.y / t) } sub(e) { return Vec2.sub(this, e) } add(e) { return Vec2.add(this, e) } mul(e) { return Vec2.mul(this, e) } div(e) { return Vec2.div(this, e) } mulFloat(e) { return Vec2.mulFloat(this, e) } divFloat(e) { return Vec2.divFloat(this, e) } len() { return Vec2.len(this) } normalized() { return Vec2.normalize(this) } } export class Vec3 { constructor(e = 0, t = 0, r = 0, i = 1) { this.x = 0, this.y = 0, this.z = 0, this.w = 1, this.x = e, this.y = t, this.z = r, this.w = i } static filledWith(e) { return new Vec3(e, e, e) } static sub(e, t) { return new Vec3(e.x - t.x, e.y - t.y, e.z - t.z) } static add(e, t) { return new Vec3(e.x + t.x, e.y + t.y, e.z + t.z) } static mul(e, t) { return new Vec3(e.x * t.x, e.y * t.y, e.z * t.z) } static div(e, t) { return new Vec3(e.x / t.x, e.y / t.y, e.z / t.z) } static mulFloat(e, t) { return new Vec3(e.x * t, e.y * t, e.z * t) } static divFloat(e, t) { return new Vec3(e.x / t, e.y / t, e.z / t) } static addFloat(e, t) { return new Vec3(e.x + t, e.y + t, e.z + t) } static subFloat(e, t) { return new Vec3(e.x - t, e.y - t, e.z - t) } static dot(e, t) { return e.x * t.x + e.y * t.y + e.z * t.z } static len(e) { return Math.sqrt(Vec3.dot(e, e)) } static normalize(e) { let t = Vec3.len(e); return 0 != t ? new Vec3(e.x / t, e.y / t, e.z / t) : new Vec3 } static cross(e, t) { let r = new Vec3; return r.x = e.y * t.z - e.z * t.y, r.y = e.z * t.x - e.x * t.z, r.z = e.x * t.y - e.y * t.x, r } static mulMat(e, t) { let r = new Vec3; return r.x = e.x * t.m[0][0] + e.y * t.m[1][0] + e.z * t.m[2][0] + e.w * t.m[3][0], r.y = e.x * t.m[0][1] + e.y * t.m[1][1] + e.z * t.m[2][1] + e.w * t.m[3][1], r.z = e.x * t.m[0][2] + e.y * t.m[1][2] + e.z * t.m[2][2] + e.w * t.m[3][2], r.w = e.x * t.m[0][3] + e.y * t.m[1][3] + e.z * t.m[2][3] + e.w * t.m[3][3], r } add(e) { return Vec3.add(this, e) } sub(e) { return Vec3.sub(this, e) } mul(e) { return Vec3.mul(this, e) } div(e) { return Vec3.div(this, e) } mulFloat(e) { return Vec3.mulFloat(this, e) } divFloat(e) { return Vec3.divFloat(this, e) } addFloat(e) { return Vec3.addFloat(this, e) } subFloat(e) { return Vec3.subFloat(this, e) } len() { return Vec3.len(this) } mulMat(e) { return Vec3.mulMat(this, e) } normalized() { return Vec3.normalize(this) } isNaN() { return isNaN(this.x) || isNaN(this.y) || isNaN(this.z) || isNaN(this.w) } equals(e) { return this.x == e.x && this.y == e.y && this.z == e.z } assign(e) { this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w } addEquals(e) { this.assign(this.add(e)) } subEquals(e) { this.assign(this.sub(e)) } mulEquals(e) { this.assign(this.mul(e)) } divEquals(e) { this.assign(this.div(e)) } addEqualsFloat(e) { this.assign(this.addFloat(e)) } subEqualsFloat(e) { this.assign(this.subFloat(e)) } mulEqualsFloat(e) { this.assign(this.mulFloat(e)) } divEqualsFloat(e) { this.assign(this.divFloat(e)) } static lerp(e, t, r) { return new Vec3(Mathematics.lerp(e.x, t.x, r), Mathematics.lerp(e.y, t.y, r), Mathematics.lerp(e.z, t.z, r)) } } export class Mat2 { constructor(e = [[0, 0], [0, 0]]) { this.m = e } flatten() { return [this.m[0][0], this.m[0][1], this.m[1][0], this.m[1][1]] } determinant() { return this.m[0][0] * this.m[1][1] - this.m[0][1] * this.m[1][0] } inverse() { return Mat2.inverse(this) } mul(e) { let t = new Mat2(this.m); for (let r = 0; r < e.length; r++) { let i = e[r], a = new Mat2; for (let e = 0; e < 2; e++)for (let r = 0; r < 2; r++)a.m[r][e] = t.m[r][0] * i.m[0][e] + t.m[r][1] * i.m[1][e]; t = a } return t } static scale(e) { let t = new Mat2; return t.m[0][0] = e.x, t.m[1][1] = e.y, t } static rotation(e) { let t = new Mat2; return t.m[0][0] = Math.cos(e), t.m[0][1] = Math.sin(e), t.m[1][0] = -Math.sin(e), t.m[1][1] = Math.cos(e), t } static identity() { let e = new Mat2; return e.m[0][0] = 1, e.m[1][1] = 0, e } static inverse(e) { let t = e.determinant(), r = new Mat2; return r.m[0][0] = e.m[0][0] / t, r.m[1][1] = e.m[1][1] / t, r.m[1][0] = e.m[1][0] / t, r.m[0][1] = e.m[0][1] / t, r } } export class Mat4 { constructor() { this.m = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]] } static perspective(e, t, r, i) { let a = 1 / Math.tan(Rotation.degToRad(.5 * e)), n = new Mat4; return n.m[0][0] = t * a, n.m[1][1] = a, n.m[2][2] = i / (i - r), n.m[3][2] = -i * r / (i - r), n.m[2][3] = 1, n.m[3][3] = 0, n } static inverse(e) { let t = new Mat4; return t.m[0][0] = e.m[0][0], t.m[0][1] = e.m[1][0], t.m[0][2] = e.m[2][0], t.m[0][3] = 0, t.m[1][0] = e.m[0][1], t.m[1][1] = e.m[1][1], t.m[1][2] = e.m[2][1], t.m[1][3] = 0, t.m[2][0] = e.m[0][2], t.m[2][1] = e.m[1][2], t.m[2][2] = e.m[2][2], t.m[2][3] = 0, t.m[3][0] = -(e.m[3][0] * t.m[0][0] + e.m[3][1] * t.m[1][0] + e.m[3][2] * t.m[2][0]), t.m[3][1] = -(e.m[3][0] * t.m[0][1] + e.m[3][1] * t.m[1][1] + e.m[3][2] * t.m[2][1]), t.m[3][2] = -(e.m[3][0] * t.m[0][2] + e.m[3][1] * t.m[1][2] + e.m[3][2] * t.m[2][2]), t.m[3][3] = 1, t } static identity() { let e = new Mat4; return e.m[0][0] = 1, e.m[1][1] = 1, e.m[2][2] = 1, e.m[3][3] = 1, e } static pointedAt(e, t, r = new Vec3(0, 1, 0)) { let i = Vec3.sub(t, e); i = Vec3.normalize(i); let a = Vec3.mulFloat(i, Vec3.dot(r, i)), n = Vec3.sub(r, a); n = Vec3.normalize(n); let s = Vec3.cross(n, i), l = new Mat4; return l.m[0][0] = s.x, l.m[0][1] = s.y, l.m[0][2] = s.z, l.m[0][3] = 0, l.m[1][0] = n.x, l.m[1][1] = n.y, l.m[1][2] = n.z, l.m[1][3] = 0, l.m[2][0] = i.x, l.m[2][1] = i.y, l.m[2][2] = i.z, l.m[2][3] = 0, l.m[3][0] = e.x, l.m[3][1] = e.y, l.m[3][2] = e.z, l.m[3][3] = 1, l } static scale(e = 1, t = 1, r = 1) { let i = Mat4.identity(); return i.m[0][0] = e, i.m[1][1] = t, i.m[2][2] = r, i } static translation(e = 0, t = 0, r = 0) { let i = new Mat4; return i.m[0][0] = 1, i.m[1][1] = 1, i.m[2][2] = 1, i.m[3][3] = 1, i.m[3][0] = e, i.m[3][1] = t, i.m[3][2] = r, i } static mul(e, t) { let r = new Mat4; for (let i = 0; i < 4; i++)for (let a = 0; a < 4; a++)r.m[a][i] = e.m[a][0] * t.m[0][i] + e.m[a][1] * t.m[1][i] + e.m[a][2] * t.m[2][i] + e.m[a][3] * t.m[3][i]; return r } static rotationX(e) { let t = new Mat4; return t.m[0][0] = 1, t.m[1][1] = Math.cos(e), t.m[1][2] = Math.sin(e), t.m[2][1] = -Math.sin(e), t.m[2][2] = Math.cos(e), t.m[3][3] = 1, t } static rotationY(e) { let t = new Mat4; return t.m[0][0] = Math.cos(e), t.m[0][2] = Math.sin(e), t.m[2][0] = -Math.sin(e), t.m[1][1] = 1, t.m[2][2] = Math.cos(e), t.m[3][3] = 1, t } static rotationZ(e) { let t = new Mat4; return t.m[0][0] = Math.cos(e), t.m[0][1] = Math.sin(e), t.m[1][0] = -Math.sin(e), t.m[1][1] = Math.cos(e), t.m[2][2] = 1, t.m[3][3] = 1, t } static rotationOnPoint(e, t) { return Mat4.mul(Mat4.mul(Mat4.translation(t.x, t.y, t.z), Mat4.mul(Mat4.mul(Mat4.rotationX(e.x), Mat4.rotationY(e.y)), Mat4.rotationZ(e.z))), Mat4.translation(-t.x, -t.y, -t.z)) } } export class Rotation { static radToDeg(e) { return 180 * e / PI } static degToRad(e) { return e * PI / 180 } } export class ShaderUniforms { } ShaderUniforms.material_diffuse = "material.diffuse", ShaderUniforms.material_specular = "material.specular", ShaderUniforms.material_normal = "material.normal", ShaderUniforms.material_parallax = "material.parallax", ShaderUniforms.material_heightScale = "material.heightScale", ShaderUniforms.material_shininess = "material.shininess", ShaderUniforms.material_scaleUV = "mesh.scaleUV", ShaderUniforms.pointLight_structName = "pointLights", ShaderUniforms.pointLight_position = "position", ShaderUniforms.pointLight_ambient = "ambient", ShaderUniforms.pointLight_diffuse = "diffuse", ShaderUniforms.pointLight_specular = "specular", ShaderUniforms.pointLight_constant = "constant", ShaderUniforms.pointLight_linear = "linear", ShaderUniforms.pointLight_quadratic = "quadratic", ShaderUniforms.directionalLight_direction = "dirLight.direction", ShaderUniforms.directionalLight_ambient = "dirLight.ambient", ShaderUniforms.directionalLight_specular = "dirLight.specular", ShaderUniforms.directionalLight_diffuse = "dirLight.diffuse", ShaderUniforms.mesh3D_modelMatrix = "mesh.transform", ShaderUniforms.mesh3D_invModelMatrix = "mesh.inverseTransform", ShaderUniforms.mesh3D_tint = "mesh.tint", ShaderUniforms.ingenium_time = "u_time", ShaderUniforms.camera3D_view = "camera.view", ShaderUniforms.camera3D_projection = "camera.projection", ShaderUniforms.camera3D_viewPos = "viewPos", ShaderUniforms.shader_numLights = "numlights", ShaderUniforms.camera2D_translation = "camera.translation", ShaderUniforms.camera2D_rotation = "camera.rotation", ShaderUniforms.camera2D_rotationPoint = "camera.rotationPoint", ShaderUniforms.camera2D_aspect = "camera.aspect", ShaderUniforms.mesh2D_tint = "model.tint", ShaderUniforms.mesh2D_translation = "model.translation", ShaderUniforms.mesh2D_rotation = "model.rotation", ShaderUniforms.mesh2D_rotationPoint = "model.rotationPoint", ShaderUniforms.mesh2D_scale = "model.scale", ShaderUniforms.mesh2D_zIndex = "model.zIndex"; export class Shader { constructor(e, t) { this.program = gl.NONE; let r = Shader.compile(e, gl.VERTEX_SHADER), i = Shader.compile(t, gl.FRAGMENT_SHADER); this.program = gl.createProgram(), gl.attachShader(this.program, r), gl.attachShader(this.program, i), gl.linkProgram(this.program) } static compile(e, t, r = "not provided") { let i = gl.createShader(t); if (gl.shaderSource(i, e), gl.compileShader(i), !gl.getShaderParameter(i, gl.COMPILE_STATUS)) { let e = { type: "SHADER_COMPILE_ERROR", id: r, shaderInt: t, shaderType: t == gl.VERTEX_SHADER ? "vertex shader" : "fragment shader", error: gl.getShaderInfoLog(i) }; return console.log(e), null } return i } static make3D(e = {}) { return new ShaderSource({}, ShaderSource.types.vert, "defvert", "#version $version(300 es)$\n#ifdef GL_ES\nprecision $precision(highp)$ float;\n#endif\n#define NORMAL_MAP $normalMap(1)$\n#define PARALLAX_MAP $parallaxMap(0)$\n#define VERTEX_RGB $vertexRGB(0)$\nlayout (location = 0) in vec4 vertexPosition;\nlayout (location = 1) in vec3 vertexUV;\nlayout (location = 2) in vec4 vertexRGB;\nlayout (location = 3) in vec3 vertexNormal;\n#if NORMAL_MAP || PARALLAX_MAP\nlayout (location = 4) in vec3 vertexTangent;\n#endif\nstruct Camera {\n    mat4 projection;\n    mat4 view;\n};\nstruct Mesh {\n    mat4 transform;\n    mat4 inverseTransform;\n    vec4 tint;\n    vec2 scaleUV;\n};\nuniform Mesh mesh;\nuniform Camera camera;\nout vec2 UV;\nout vec4 tint;\nout vec3 normal;\nout vec3 fragPos;\nout mat3 TBN;\nmat3 getTBN (vec3 norm, vec3 tangentTheta) {\n    norm = normalize(norm);\n    vec3 tangent = normalize(tangentTheta);\n    tangent = normalize(tangent - dot(tangent, norm) * norm);\n    vec3 bitangent = cross(tangent, norm);\n    return mat3(tangent, bitangent, norm);\n}\nvoid main () {\n    vec4 transformed = camera.projection * camera.view * mesh.transform * vertexPosition;\n    transformed.x = -transformed.x;\n    gl_Position = transformed;\n    UV = vertexUV.xy * mesh.scaleUV;\n#if VERTEX_RGB\n    tint = vertexRGB * mesh.tint;\n#else\n    tint = mesh.tint;\n#endif\n    normal = mat3(transpose(mesh.inverseTransform)) * vertexNormal;\n    fragPos = vec3(mesh.transform * vertexPosition);\n#if NORMAL_MAP || PARALLAX_MAP\n    vec3 tangentTheta = (mesh.transform * vec4(vertexTangent, 0.0)).xyz;   \n    TBN = getTBN(normal, tangentTheta);\n#endif\n}"), new ShaderSource({}, ShaderSource.types.frag, "deffrag", "#version $version(300 es)$\n#ifdef GL_ES\nprecision $precision(mediump)$ float;\n#endif\n#define $lightModel(BLINN)$ 1\n#define NORMAL_MAP $normalMap(1)$\n#define PARALLAX_MAP $parallaxMap(0)$\n#define PARALLAX_CLIP_EDGE $parallaxClipEdge(0)$\n#define MIN_PARALLAX_LAYERS $minParallaxLayers(8.0)$\n#define MAX_PARALLAX_LAYERS $maxParallaxLayers(32.0)$\n#define PARALLAX_INVERT $parallaxInvert(0)$\n#define MAX_POINT_LIGHTS $maxPointLights(0)$\nlayout (location = 0) out vec4 color;\nstruct Material {\n    sampler2D diffuse;\n    sampler2D specular;\n    sampler2D normal;\n    sampler2D parallax;\n    float heightScale;\n    float shininess;\n};\nstruct DirLight {\n    vec3 direction;\n  \n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n};  \nstruct PointLight {    \n    vec3 position;\n    \n    float constant;\n    float linear;\n    float quadratic;  \n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n};  \nuniform float u_time;\nuniform Material material;\nuniform DirLight dirLight;\nuniform vec3 viewPos;\nuniform int numlights;\n#if (MAX_POINT_LIGHTS > 0)\nuniform PointLight pointLights[MAX_POINT_LIGHTS];\n#endif\nin vec2 UV;\nin vec4 tint;\nin vec3 normal;\nin vec3 fragPos;\n#if PARALLAX_MAP || NORMAL_MAP\nin mat3 TBN;\n#endif\n#if NORMAL_MAP\nvec3 CalcBumpedNormal(vec2 cUV)\n{\n    vec3 BumpMapNormal = texture(material.normal, cUV).xyz;\n    BumpMapNormal = 2.0 * BumpMapNormal - vec3(1.0, 1.0, 1.0);\n    vec3 NewNormal = TBN * BumpMapNormal;\n    NewNormal = normalize(NewNormal);\n    return NewNormal;\n}\n#endif // NORMAL_MAP\n#if !defined(NONE)\nvec4 CalcDirLight(DirLight light, vec3 cnormal, vec3 viewDir, vec2 coordUV)\n{\n    vec3 lightDir = normalize(-light.direction);\n    float diff = max(dot(cnormal, lightDir), 0.0);\n    vec3 reflectDir = reflect(-lightDir, cnormal);\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);\n    vec4 ambient  = vec4(light.ambient, 1.0)  * (texture(material.diffuse, coordUV).rgba * tint.rgba);\n    vec4 diffuse  = vec4(light.diffuse  * diff, 1.0) * (texture((material.diffuse), coordUV).rgba * tint.rgba);\n    vec4 specular = vec4(light.specular * spec, 1.0) * (texture(material.specular, coordUV).rgba * tint.rgba);\n    return vec4(ambient.rgb + diffuse.rgb + specular.rgb, (ambient.a + diffuse.a + specular.a) * 0.333);\n} \nvec4 CalcPointLight(PointLight light, vec3 cnormal, vec3 cfragPos, vec3 viewDir, vec2 coordUV)\n{\n    vec3 lightDir = normalize(light.position - cfragPos);\n    float diff = max(dot(cnormal, lightDir), 0.0);\n    #if defined(PHONG)  \n    vec3 reflectDir = reflect(-lightDir, cnormal);\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);\n    #endif // defined(PHONG)\n    #if defined(BLINN)\n    vec3 halfwayDir = normalize(lightDir + viewDir);\n    float spec = pow(max(dot(cnormal, halfwayDir), 0.0), material.shininess);\n    #endif // defined(BLINN)\n    float distance    = length(light.position - cfragPos);\n    float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));    \n    vec4 ambient  = vec4(light.ambient, 1.0)  * texture(material.diffuse, coordUV).rgba * tint.rgba;\n    vec4 diffuse  = vec4(light.diffuse * diff, 1.0) * texture(material.diffuse, coordUV).rgba * tint.rgba;\n    vec4 specular = vec4(light.specular * spec, 1.0) * texture(material.specular, coordUV).rgba * tint.rgba;\n    ambient  *= attenuation;\n    diffuse  *= attenuation;\n    specular *= attenuation;\n    return vec4(ambient.rgb + diffuse.rgb + specular.rgb, (ambient.a * diffuse.a * specular.a) * 0.333);\n}\n#endif // !defined(NONE)\n#if PARALLAX_MAP\nvec2 ParallaxMapping(vec2 texCoords, vec3 viewDir)\n{ \n    float numLayers = mix(MAX_PARALLAX_LAYERS, MIN_PARALLAX_LAYERS, abs(dot(normalize(normal), viewDir)));  \n    float layerDepth = 1.0 / numLayers;\n    float currentLayerDepth = 0.0;\n    // vec2 P = viewDir.xy / viewDir.z * material.heightScale; \n    vec2 P = viewDir.xy * material.heightScale;\n    vec2 deltaTexCoords = P / numLayers;\n    vec2  currentTexCoords     = texCoords;\n    #if PARALLAX_INVERT\n    float currentDepthMapValue = 1.0 - texture(material.parallax, currentTexCoords).r;\n    #else\n    float currentDepthMapValue = texture(material.parallax, currentTexCoords).r;\n    #endif // PARALLAX_INVERT\n    while(currentLayerDepth < currentDepthMapValue)\n    {\n        currentTexCoords -= deltaTexCoords;\n    #if PARALLAX_INVERT\n        currentDepthMapValue = 1.0 - texture(material.parallax, currentTexCoords).r; \n    #else\n        currentDepthMapValue = texture(material.parallax, currentTexCoords).r; \n    #endif // PARALLAX_INVERT\n        currentLayerDepth += layerDepth;  \n    }\n    vec2 prevTexCoords = currentTexCoords + deltaTexCoords;\n    float afterDepth  = currentDepthMapValue - currentLayerDepth;\n    #if PARALLAX_INVERT\n    float beforeDepth = 1.0 - texture(material.parallax, prevTexCoords).r - currentLayerDepth + layerDepth;\n    #else\n    float beforeDepth = texture(material.parallax, prevTexCoords).r - currentLayerDepth + layerDepth;\n    #endif // PARALLAX_INVERT\n    float weight = afterDepth / (afterDepth - beforeDepth);\n    vec2 finalTexCoords = prevTexCoords * weight + currentTexCoords * (1.0 - weight);\n    return finalTexCoords;\n}\n#endif // PARALLAX_MAP\nvoid main () \n{\n    vec2 cUV = UV;\n    vec3 viewDir = normalize(viewPos - fragPos);\n#if PARALLAX_MAP\n    vec3 tangentViewDir = normalize(TBN * viewDir);\n    cUV = ParallaxMapping(cUV, tangentViewDir);\n    #if PARALLAX_CLIP_EDGE\n    if(cUV.x > 1.0 || cUV.y > 1.0 || cUV.x < 0.0 || cUV.y < 0.0)\n        discard;\n    #endif // PARALLAX_CLIP_EDGE\n#endif // PARALLAX_MAP\n#if NORMAL_MAP\n    vec3 norm = CalcBumpedNormal(cUV);\n#else\n    vec3 norm = normalize(normal);\n#endif // NORMAL_MAP\n#if PARALLAX_MAP\n    vec4 result = CalcDirLight(dirLight, norm, tangentViewDir, cUV);\n#else\n    #if !defined(NONE)\n    vec4 result = CalcDirLight(dirLight, norm, viewDir, cUV);\n    #else\n    vec4 result = texture(material.diffuse, cUV).rgba * tint.rgba;\n    #endif // !defined(NONE)\n#endif // PARALLAX_MAP\n#if !defined(NONE)\n    #if MAX_POINT_LIGHTS > 0\n    for(int i = 0; i < numlights; i++) {\n        #if PARALLAX_MAP\n        result += CalcPointLight(pointLights[i], norm, fragPos, tangentViewDir, cUV);\n        #else\n        result += CalcPointLight(pointLights[i], norm, fragPos, viewDir, cUV);\n        #endif // PARALLAX_MAP\n    }\n    result.a /= float(numlights);\n    #endif // MAX_POINT_LIGHTS > 0\n#endif // !defined(NONE)\n    color = result;\n}"), new Shader(ShaderSource.shaderWithParams("defvert", e), ShaderSource.shaderWithParams("deffrag", e)) } use() { gl.useProgram(this.program) } getULoc(e) { return gl.getUniformLocation(this.program, e) } setUInt(e, t) { gl.uniform1i(this.getULoc(e), t) } setUInt2(e, t, r) { gl.uniform2i(this.getULoc(e), t, r) } setUInt3(e, t, r, i) { gl.uniform3i(this.getULoc(e), t, r, i) } setUInt4(e, t, r, i, a) { gl.uniform4i(this.getULoc(e), t, r, i, a) } setUFloat(e, t) { gl.uniform1f(this.getULoc(e), t) } setUFloat2(e, t, r) { gl.uniform2f(this.getULoc(e), t, r) } setUFloat3(e, t, r, i) { gl.uniform3f(this.getULoc(e), t, r, i) } setUFloat4(e, t, r, i, a) { gl.uniform4f(this.getULoc(e), t, r, i, a) } setUMat4(e, t) { gl.uniformMatrix4fv(this.getULoc(e), !1, t.m.flat()) } setUVec2(e, t) { this.setUFloat2(e, t.x, t.y) } setUVec3(e, t) { this.setUFloat3(e, t.x, t.y, t.z) } setUVec4(e, t) { this.setUFloat4(e, t.x, t.y, t.z, t.w) } setUBool(e, t) { this.setUInt(e, t ? 1 : 0) } setUMat2(e, t) { gl.uniformMatrix2fv(this.getULoc(e), !1, t.flatten()) } } class ShaderSourceTypes { constructor() { this.vert = "vertex", this.frag = "fragment" } } export class ShaderSource { constructor(e, t, r, i) { this.params = e, this.source = i, this.type = t, ShaderSource.shaders[r] = this } static shaderWithParams(e, t = {}) { let r = Object.keys(t), i = ShaderSource.shaders[e].source; const a = i.matchAll(/\$.+\(.*\)\$/gm); for (const e of a) { let t = e[0].replace(/\$/g, ""), a = t.substring(0, t.indexOf("(")) + t.substring(t.lastIndexOf(")") + 1), n = t.substring(t.indexOf("(") + 1, t.lastIndexOf(")")); i = r.includes(a) ? i.replace(t, r[a]) : i.replace(t, n) } return i.replace(/\$/g, "") } static getShader(e) { return ShaderSource.shaders[e] } static getAllShaderNames() { return Object.keys(ShaderSource.shaders) } getExpectedParams() { return Object.keys(this.params) } static makeFromFile(e, t, r, i) { return new ShaderSource(e, t, r, Utils.loadFile(i)) } } ShaderSource.types = new ShaderSourceTypes, ShaderSource.shaders = {}; export class Vert3D { constructor(e = new Vec3, t = new Vec2, r = new Vec3(1, 1, 1), i = new Vec3) { this.rgb = new Vec3(1, 1, 1), this.p = e, this.t = t, this.rgb = r, this.n = i } } Vert3D.tSize = 17; export class Vert2D { constructor(e = new Vec2, t = new Vec2) { this.p = e, this.t = t } } Vert2D.tSize = 4; export class Tri3D { constructor(e = [new Vert3D, new Vert3D, new Vert3D]) { this.v = [e[0], e[1], e[2]] } } export class Tri2D { constructor(e = [new Vert2D, new Vert2D, new Vert2D]) { this.v = [e[0], e[1], e[2]] } } export class Material { constructor(e = null, t = null, r = null, i = .5) { this.shininess = .5, this.parallaxScale = 0, this.UVScale = Vec2.filledWith(1), this.diffuseTexture = e, this.specularTexture = t, this.normalTexture = r, this.parallaxTexture = null, this.shininess = i } bindTextures() { gl.activeTexture(gl.TEXTURE0), gl.bindTexture(gl.TEXTURE_2D, this.diffuseTexture), gl.activeTexture(gl.TEXTURE1), gl.bindTexture(gl.TEXTURE_2D, this.specularTexture), gl.activeTexture(gl.TEXTURE2), gl.bindTexture(gl.TEXTURE_2D, this.normalTexture), gl.activeTexture(gl.TEXTURE3), gl.bindTexture(gl.TEXTURE_2D, this.parallaxTexture) } static sendToShader(e) { e.setUInt(ShaderUniforms.material_diffuse, 0), e.setUInt(ShaderUniforms.material_specular, 1), e.setUInt(ShaderUniforms.material_normal, 2), e.setUInt(ShaderUniforms.material_parallax, 3), e.setUInt("screenTexture", 0) } } export class ReferenceMaterial { constructor() { this.diffuseTexture = gl.NONE, this.specularTexture = gl.NONE, this.normalTexture = gl.NONE, this.parallaxTexture = gl.NONE } } export class Position3D { constructor(e = new Vec3, t = new Vec3) { this.position = e, this.rotation = t } } export class Position2D { constructor(e = new Vec2, t = 0) { this.position = e, this.rotation = t } } export class Camera3D extends Position3D { constructor(e = 75, t = .1, r = 500, i = 9 / 16) { super(), this.FOV = e, this.clipNear = t, this.clipFar = r, this.aspect = i } lookVector() { let e = new Vec3(0, 0, 1), t = Mat4.mul(Mat4.mul(Mat4.rotationX(this.rotation.x), Mat4.rotationY(this.rotation.y)), Mat4.rotationZ(this.rotation.z)); return e = Vec3.mulMat(e, t) } perspective() { return Mat4.perspective(this.FOV, this.aspect, this.clipNear, this.clipFar) } cameraMatrix() { let e = new Vec3(0, 1, 0), t = new Vec3(0, 0, 1), r = Mat4.rotationY(this.rotation.y), i = Mat4.rotationX(this.rotation.x), a = Mat4.rotationZ(this.rotation.z), n = Vec3.mulMat(t, Mat4.mul(Mat4.mul(i, r), a)); return t = Vec3.add(this.position, n), Mat4.pointedAt(this.position, t, e) } stdControl(e = 1, t = 1) { let r = Camera3D.stdController(this, this, e, t); this.position = r.position, this.rotation = r.rotation } static stdController(e, t, r = 1, i = 1) { let a = e.lookVector(), n = t, s = new Vec3, l = new Vec3(0, 1, 0), o = new Vec3; return Input.getKeyState("w") && (s = Vec3.add(s, a)), Input.getKeyState("s") && (s = Vec3.mulFloat(Vec3.add(s, a), -1)), Input.getKeyState("d") && (s = Vec3.add(s, Vec3.cross(a, l))), Input.getKeyState("a") && (s = Vec3.add(s, Vec3.mulFloat(Vec3.cross(a, l), -1))), (Input.getKeyState("q") || Input.getKeyState(" ")) && (s.y = s.y + 1), Input.getKeyState("e") && (s.y = s.y - 1), Input.getKeyState("ArrowLeft") && (o.y = -i), Input.getKeyState("ArrowRight") && (o.y = i), Input.getKeyState("ArrowUp") && (o.x = -i), Input.getKeyState("ArrowDown") && (o.x = i), n.rotation = Vec3.add(n.rotation, Vec3.mulFloat(o, Time.deltaTime)), n.position = Vec3.add(n.position, Vec3.mulFloat(Vec3.normalize(s), r * Time.deltaTime)), n.rotation.x >= Rotation.degToRad(87) && (n.rotation.x = Rotation.degToRad(87)), n.rotation.x <= -Rotation.degToRad(87) && (n.rotation.x = -Rotation.degToRad(87)), Math.abs(n.rotation.y) >= Rotation.degToRad(360) && (n.rotation.y = 0), Math.abs(n.rotation.z) >= Rotation.degToRad(360) && (n.rotation.z = 0), n } } export class Camera2D extends Position2D { constructor(e, t = new Vec2, r = 0) { super(t, r), this.rotationPoint = new Vec2, this.aspect = e } cameraMatrix() { return Mat2.rotation(this.rotation) } sendToShader(e) { e.setUMat2("camera.rotation", this.cameraMatrix()), e.setUVec2("camera.translation", this.position), e.setUFloat("camera.aspect", this.aspect), e.setUVec2("camera.rotationPoint", this.rotationPoint) } stdControl(e, t) { let r = new Vec2, i = new Vec2(Math.sin(this.rotation), Math.cos(this.rotation)), a = 0; Input.getKeyState("w") && (r = r.sub(i)), Input.getKeyState("s") && (r = r.add(i)), Input.getKeyState("d") && (r = r.add(new Vec2(Math.sin(this.rotation - 1.5708), Math.cos(this.rotation - 1.5708)))), Input.getKeyState("a") && (r = r.add(new Vec2(Math.sin(this.rotation + 1.5708), Math.cos(this.rotation + 1.5708)))), Input.getKeyState("ArrowLeft") && (a -= t), Input.getKeyState("ArrowRight") && (a += t), this.position = this.position.add(r.normalized().mulFloat(Time.deltaTime * e)), this.rotation = this.rotation + a * Time.deltaTime } } let loadedImages = {}, loadedGeometry = {}, loadedReferenceTextures = {}, loadedReferenceGeometry = {}; export class Mesh3D extends Position3D { constructor(e = new Vec3, t = new Vec3, r = new Vec3, i = new Vec3(1, 1, 1), a = new Material) { super(e, t), this.tint = new Vec3(1, 1, 1), this.triangles = 0, this.useGeometryReferenceCache = !1, this.useTextureReferenceCache = !0, this.renderTransparent = !1, this.rotationCenter = r, this.scale = i, this.material = a, this.loaded = !1, this.mVBO = gl.NONE, this.mVAO = gl.NONE, this.data = [] } make(e, t = "NONE", r = "NONE", i = "NONE", a = "NONE") { if (this.useGeometryReferenceCache && Object.keys(loadedReferenceGeometry).includes(e)) { let t = loadedReferenceGeometry[e]; this.mVBO = t.VBO, this.mVAO = t.VAO, this.triangles = t.triangles, this.loaded = !0 } else if (Object.keys(loadedGeometry).includes(e)) this.loadFromObjData(loadedGeometry[e].data); else { let t = new Geometry(Utils.loadFile(e), "USER_GEOMETRY"); loadedGeometry[e] = t, this.loadFromObjData(t.data) } if (this.setTexture(t, r, i, a), this.load(), !Object.keys(loadedReferenceGeometry).includes(e)) { let t = new ReferenceGeometry; t.VBO = this.mVBO, t.VAO = this.mVAO, t.triangles = this.triangles, loadedReferenceGeometry[e] = t } } loadFromObjData(e) { let t = [], r = [], i = [], a = e.split("\n"), n = e.includes("vn"), s = e.includes("vt"); for (let e = 0; e < a.length; e++) { let l = a[e]; if ("v" == l[0]) if ("t" == l[1]) { let e = new Vec2, t = l.split(" "); e.x = parseFloat(t[1]), e.y = parseFloat(t[2]), i.push(e) } else if ("n" == l[1]) { let e = new Vec3, t = l.split(" "); e.x = parseFloat(t[1]), e.y = parseFloat(t[2]), e.z = parseFloat(t[3]), r.push(e) } else { let e = new Vec3, r = l.split(" "); e.x = parseFloat(r[1]), e.y = parseFloat(r[2]), e.z = parseFloat(r[3]), t.push(e) } if ("f" == l[0]) { let e = 1; n && e++, s && e++; let a = [], o = l.replace("f", "").split(/[\/\s]+/g); for (let e = 1; e < o.length; e++)a.push(parseInt(o[e])); let m = new Tri3D; for (let l = 0; l < 3; l++)m.v[l].p = t[a[e * l] - 1], s && (m.v[l].t = i[a[e * l + 1] - 1]), n && !s && (m.v[l].n = r[a[e * l + 1] - 1]), n && s && (m.v[l].n = r[a[e * l + 2] - 1]); this.addTriangle(m) } } } addTriangle(e) { let t = Mesh3D.calcTangents(e); for (let r = 0; r < 3; r++)this.data.push(e.v[r].p.x), this.data.push(e.v[r].p.y), this.data.push(e.v[r].p.z), this.data.push(e.v[r].p.w), this.data.push(e.v[r].t.x), this.data.push(e.v[r].t.y), this.data.push(e.v[r].t.w), this.data.push(e.v[r].rgb.x), this.data.push(e.v[r].rgb.y), this.data.push(e.v[r].rgb.z), this.data.push(e.v[r].rgb.w), this.data.push(e.v[r].n.x), this.data.push(e.v[r].n.y), this.data.push(e.v[r].n.z), this.data.push(t[r].x), this.data.push(t[r].y), this.data.push(t[r].z); this.triangles++ } render(e, t, r = new DirectionalLight, i = []) { Mesh3D.renderAll(e, t, [this], r, i) } static createTextureFromImage(e, t = gl.TEXTURE0, r = [gl.REPEAT, gl.REPEAT], i = gl.LINEAR_MIPMAP_LINEAR, a = gl.LINEAR) { let n = gl.NONE; return n = gl.createTexture(), gl.activeTexture(t), gl.bindTexture(gl.TEXTURE_2D, n), gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(Mesh3D.defaultColour)), e.complete ? (gl.activeTexture(t), gl.bindTexture(gl.TEXTURE_2D, n), gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, e), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, r[0]), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, r[1]), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, i), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, a), gl.generateMipmap(gl.TEXTURE_2D)) : e.addEventListener("load", () => { gl.activeTexture(t), gl.bindTexture(gl.TEXTURE_2D, n), gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, e), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, r[0]), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, r[1]), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, i), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, a), gl.generateMipmap(gl.TEXTURE_2D) }), n } static createTextureFromRGBAPixelArray(e, t, r, i = gl.TEXTURE0, a = [gl.REPEAT, gl.REPEAT], n = gl.LINEAR_MIPMAP_LINEAR, s = gl.LINEAR) { let l = gl.createTexture(); return gl.activeTexture(i), gl.bindTexture(gl.TEXTURE_2D, l), gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, t, r, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(e)), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, a[0]), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, a[1]), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, n), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, s), gl.generateMipmap(gl.TEXTURE_2D), l } static createTextureFromRGBPixelArray(e, t, r, i = gl.TEXTURE0, a = [gl.REPEAT, gl.REPEAT], n = gl.LINEAR_MIPMAP_LINEAR, s = gl.LINEAR) { let l = gl.createTexture(); return gl.activeTexture(i), gl.bindTexture(gl.TEXTURE_2D, l), gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, t, r, 0, gl.RGB, gl.UNSIGNED_BYTE, new Uint8Array(e)), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, a[0]), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, a[1]), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, n), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, s), gl.generateMipmap(gl.TEXTURE_2D), l } static createColorTexture(e, t = 1, r = gl.TEXTURE0, i = [gl.REPEAT, gl.REPEAT], a = gl.LINEAR_MIPMAP_LINEAR, n = gl.LINEAR) { let s = (16711680 & e) >> 16, l = (65280 & e) >> 8, o = 255 & e; return Mesh3D.createTextureFromRGBAPixelArray([s, l, o, 255 * t], 1, 1, r, i, a, n) } static createTextureFromPath(e, t = gl.TEXTURE0, r, i = [gl.REPEAT, gl.REPEAT], a = gl.LINEAR_MIPMAP_LINEAR, n = gl.LINEAR) { if (r && Object.keys(loadedReferenceTextures).includes(e)) return loadedReferenceTextures[e]; let s = gl.NONE; if (s = gl.createTexture(), gl.activeTexture(t), gl.bindTexture(gl.TEXTURE_2D, s), gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(Mesh3D.defaultColour)), "NONE" != e) { let r; Object.keys(loadedImages).includes(e) && loadedImages[e].complete ? (r = loadedImages[e], gl.activeTexture(t), gl.bindTexture(gl.TEXTURE_2D, s), gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, r), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, i[0]), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, i[1]), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, a), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, n), gl.generateMipmap(gl.TEXTURE_2D)) : ((r = new Image).src = e, r.crossOrigin = "anonymous", loadedImages[e] = r, r.addEventListener("load", () => { gl.activeTexture(t), gl.bindTexture(gl.TEXTURE_2D, s), gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, r), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, i[0]), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, i[1]), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, a), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, n), gl.generateMipmap(gl.TEXTURE_2D) })) } return Object.keys(loadedReferenceTextures).includes(e) ? s : loadedReferenceTextures[e] = s } static createEmpty(e) { let t = new Mesh3D; for (let r = 0; r < e * Vert3D.tSize; r++)t.data.push(0); return t.load(), t.triangles = e / 3, t } static createAndMake(e, t = "NONE", r = "NONE", i = "NONE", a = "NONE") { let n = new Mesh3D; return n.make(e, t, r, i, a), n } setRawVertexData(e, t) { for (let r = 0; r < t.length; r++)this.data[e + r] = t[r]; gl.bindBuffer(gl.ARRAY_BUFFER, this.mVBO), gl.bufferSubData(gl.ARRAY_BUFFER, 4 * e, new Float32Array(this.data)) } getRawVertexdata(e, t, r = 1) { let i = [], a = 0; for (let n = 0; n < t; n += r)i[a] = this.data[e + n], a++; return i } setTexture(e, t = "NONE", r = "NONE", i = "NONE") { this.material.diffuseTexture = Mesh3D.createTextureFromPath(e, gl.TEXTURE0, this.useTextureReferenceCache), this.material.specularTexture = Mesh3D.createTextureFromPath(t, gl.TEXTURE1, this.useTextureReferenceCache), this.material.normalTexture = Mesh3D.createTextureFromPath(r, gl.TEXTURE2, this.useTextureReferenceCache), this.material.parallaxTexture = Mesh3D.createTextureFromPath(i, gl.TEXTURE3, this.useTextureReferenceCache) } modelMatrix() { let e = Mat4.rotationOnPoint(this.rotation, this.rotationCenter), t = Mat4.translation(this.position.x, this.position.y, this.position.z), r = Mat4.scale(this.scale.x, this.scale.y, this.scale.z); return Mat4.mul(Mat4.mul(r, e), t) } load(e = gl.DYNAMIC_DRAW) { if (!this.loaded) { this.mVBO = gl.createBuffer(), gl.bindBuffer(gl.ARRAY_BUFFER, this.mVBO), gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.data), e), this.mVAO = gl.createVertexArray(), gl.bindVertexArray(this.mVAO), gl.bindBuffer(gl.ARRAY_BUFFER, this.mVBO); let t = 4, r = Vert3D.tSize * t; gl.vertexAttribPointer(0, 4, gl.FLOAT, !1, r, 0), gl.enableVertexAttribArray(0), gl.vertexAttribPointer(1, 3, gl.FLOAT, !1, r, 4 * t), gl.enableVertexAttribArray(1), gl.vertexAttribPointer(2, 4, gl.FLOAT, !1, r, 7 * t), gl.enableVertexAttribArray(2), gl.vertexAttribPointer(3, 4, gl.FLOAT, !1, r, 11 * t), gl.enableVertexAttribArray(3), gl.vertexAttribPointer(4, 3, gl.FLOAT, !1, r, 14 * t), gl.enableVertexAttribArray(4), gl.bindBuffer(gl.ARRAY_BUFFER, null), this.loaded = !0 } } static calcTangents(e) { let t = e.v[0].p, r = e.v[1].p, i = e.v[2].p, a = e.v[0].t, n = e.v[1].t, s = e.v[2].t, l = r.x - t.x, o = i.x - t.x, m = r.y - t.y, c = i.y - t.y, h = r.z - t.z, d = i.z - t.z, g = n.x - a.x, u = s.x - a.x, T = n.y - a.y, f = s.y - a.y, p = 1 / (g * f - u * T), x = new Vec3((f * l - T * o) * p, (f * m - T * c) * p, (f * h - T * d) * p), E = new Vec3((g * o - u * l) * p, (g * c - u * m) * p, (g * d - u * h) * p), R = [x, x, x]; for (var U = 0; U < 3; U++) { let t = R[U], r = e.v[U].n; (t = t.sub(r).mulFloat(Vec3.dot(r, t)).normalized()).w = Vec3.dot(Vec3.cross(r, t), E) < 0 ? -1 : 1 } return R } static renderAll(e, t, r, i = new DirectionalLight, a = []) { e.use(), Material.sendToShader(e), e.setUFloat(ShaderUniforms.ingenium_time, (Date.now() - IngeniumWeb.startTime) / 1e3), e.setUMat4(ShaderUniforms.camera3D_view, Mat4.inverse(t.cameraMatrix())), e.setUMat4(ShaderUniforms.camera3D_projection, t.perspective()), e.setUVec3(ShaderUniforms.camera3D_viewPos, t.position), e.setUInt(ShaderUniforms.shader_numLights, a.length), i.sendToShader(e); for (let t = 0; t < a.length; t++)a[t].sendToShader(e, t); let n = []; for (let t = 0; t < r.length; t++)1 != r[t].tint.w || r[t].renderTransparent ? n.push(r[t]) : Mesh3D.renderMeshRaw(r[t], e); n.sort((e, r) => { let i = t.position.sub(e.position).len(), a = t.position.sub(r.position).len(); return i < a ? 1 : i > a ? -1 : 0 }); for (let t = 0; t < n.length; t++)Mesh3D.renderMeshRaw(n[t], e) } static renderMeshRaw(e, t) { gl.bindVertexArray(e.mVAO); let r = e.modelMatrix(); t.setUMat4(ShaderUniforms.mesh3D_modelMatrix, r), t.setUMat4(ShaderUniforms.mesh3D_invModelMatrix, Mat4.inverse(r)), t.setUVec4(ShaderUniforms.mesh3D_tint, e.tint), t.setUFloat(ShaderUniforms.material_shininess, e.material.shininess), t.setUFloat(ShaderUniforms.material_heightScale, e.material.parallaxScale), t.setUVec2(ShaderUniforms.material_scaleUV, e.material.UVScale), e.material.bindTextures(); let i = 3 * e.triangles; gl.drawArrays(gl.TRIANGLES, 0, i) } } Mesh3D.defaultColour = [128, 128, 255, 255]; export class Mesh2D extends Position2D { constructor(e = new Vec2, t = 0, r = Vec2.filledWith(1), i = new Vec2, a = new Material) { super(e, t), this.tint = new Vec3(1, 1, 1), this.triangles = 0, this.useGeometryReferenceCache = !1, this.useTextureReferenceCache = !0, this.renderTransparent = !1, this.zIndex = 0, this.scale = r, this.rotationCenter = i, this.material = a } load(e = gl.STATIC_DRAW) { if (!this.loaded) { this.mVBO = gl.createBuffer(), gl.bindBuffer(gl.ARRAY_BUFFER, this.mVBO), gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.data), e), this.mVAO = gl.createVertexArray(), gl.bindVertexArray(this.mVAO), gl.bindBuffer(gl.ARRAY_BUFFER, this.mVBO); let t = 4, r = Vert2D.tSize * t; gl.vertexAttribPointer(0, 2, gl.FLOAT, !1, r, 0), gl.enableVertexAttribArray(0), gl.vertexAttribPointer(1, 2, gl.FLOAT, !1, r, 2 * t), gl.enableVertexAttribArray(1), this.loaded = !0 } } modelMatrix() { return Mat2.rotation(this.rotation) } sendToShader(e) { e.setUVec4("model.tint", this.tint), e.setUVec2("model.translation", this.position), e.setUMat2("model.rotation", this.modelMatrix()), e.setUVec2("model.rotationPoint", this.rotationCenter), e.setUVec2("model.scale", this.scale), e.setUFloat("model.zIndex", this.zIndex), gl.activeTexture(gl.TEXTURE0), gl.bindTexture(gl.TEXTURE_2D, this.material.diffuseTexture) } bindVBO() { gl.bindBuffer(gl.ARRAY_BUFFER, this.mVBO) } bindVAO() { gl.bindVertexArray(this.mVAO) } static renderAll(e, t, r) { e.use(), Material.sendToShader(e), t.sendToShader(e), e.setUFloat("u_time", Date.now()); for (let i = 0; i < r.length; i++)r[i].bindVAO(), e.setUVec2("translation", r[i].position.add(t.position)), r[i].sendToShader(e), gl.drawArrays(gl.TRIANGLES, 0, 3 * r[i].triangles) } } Mesh2D.renderTranslationName = "translation"; export class Light { constructor(e, t, r, i) { this.ambient = e, this.diffuse = t, this.specular = r, this.intensity = i } } export class PointLight extends Light { constructor(e = new Vec3(.05, .05, .05), t = new Vec3(.8, .8, .8), r = new Vec3(.2, .2, .2), i = new Vec3, a = 1) { super(e, t, r, a), this.constant = 1, this.linear = .09, this.quadratic = .032, this.position = i } sendToShader(e, t) { e.setUVec3(ShaderUniforms.pointLight_structName + "[" + t + "]." + ShaderUniforms.pointLight_position, this.position), e.setUVec3(ShaderUniforms.pointLight_structName + "[" + t + "]." + ShaderUniforms.pointLight_ambient, this.ambient), e.setUVec3(ShaderUniforms.pointLight_structName + "[" + t + "]." + ShaderUniforms.pointLight_diffuse, Vec3.mulFloat(this.diffuse, this.intensity)), e.setUVec3(ShaderUniforms.pointLight_structName + "[" + t + "]." + ShaderUniforms.pointLight_specular, Vec3.mulFloat(this.specular, this.intensity)), e.setUFloat(ShaderUniforms.pointLight_structName + "[" + t + "]." + ShaderUniforms.pointLight_constant, this.constant), e.setUFloat(ShaderUniforms.pointLight_structName + "[" + t + "]." + ShaderUniforms.pointLight_linear, this.linear), e.setUFloat(ShaderUniforms.pointLight_structName + "[" + t + "]." + ShaderUniforms.pointLight_quadratic, this.quadratic) } } export class DirectionalLight extends Light { constructor(e = new Vec3(.2, .2, .2), t = new Vec3(.8, .8, .8), r = new Vec3(.2, .2, .2), i = new Vec3(0, -1, .2), a = 1) { super(e, t, r, a), this.direction = i } sendToShader(e) { e.setUVec3(ShaderUniforms.directionalLight_direction, this.direction), e.setUVec3(ShaderUniforms.directionalLight_ambient, this.ambient), e.setUVec3(ShaderUniforms.directionalLight_specular, this.specular.mulFloat(this.intensity)), e.setUVec3(ShaderUniforms.directionalLight_diffuse, this.diffuse.mulFloat(this.intensity)) } } export class Geometry { constructor(e, t = "NONE") { this.data = e, this.name = t } static makeCube() { return new Geometry(cubeData, "Default Cube") } } Geometry.quadData = [-1, 1, 0, 1, -1, -1, 0, 0, 1, 1, 1, 1, -1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1], Geometry.triData = [0, 1, .5, 1, -1, -1, 0, 0, 1, -1, 1, 0]; export class ReferenceGeometry { } let cubeData = "v -1.000000 1.000000 -1.000000\nv 1.000000 1.000000 1.000000\nv 1.000000 1.000000 -1.000000\nv -1.000000 -1.000000 1.000000\nv 1.000000 -1.000000 1.000000\nv -1.000000 1.000000 1.000000\nv -1.000000 -1.000000 -1.000000\nv 1.000000 -1.000000 -1.000000\nvt 1.000000 0.000000\nvt 0.666667 0.333333\nvt 0.666667 0.000000\nvt 0.333333 0.333333\nvt 0.000000 0.000000\nvt 0.333333 0.000000\nvt 0.333333 0.666667\nvt 0.000000 0.333333\nvt 0.333333 0.333333\nvt 0.666667 0.000000\nvt 0.333333 0.000000\nvt 0.666667 0.666667\nvt 0.333333 0.333333\nvt 0.666667 0.333333\nvt 0.333333 1.000000\nvt 0.000000 0.666667\nvt 0.333333 0.666667\nvt 1.000000 0.333333\nvt 0.000000 0.333333\nvt 0.000000 0.666667\nvt 0.666667 0.333333\nvt 0.333333 0.666667\nvt 0.000000 1.000000\nvn 0.0000 1.0000 0.0000\nvn 0.0000 -0.0000 1.0000\nvn -1.0000 0.0000 0.0000\nvn 0.0000 -1.0000 -0.0000\nvn 1.0000 0.0000 0.0000\nvn 0.0000 0.0000 -1.0000\ns off\nf 1/1/1 2/2/1 3/3/1\nf 2/4/2 4/5/2 5/6/2\nf 6/7/3 7/8/3 4/9/3\nf 8/10/4 4/9/4 7/11/4\nf 3/12/5 5/13/5 8/14/5\nf 1/15/6 8/16/6 7/17/6\nf 1/1/1 6/18/1 2/2/1\nf 2/4/2 6/19/2 4/5/2\nf 6/7/3 1/20/3 7/8/3\nf 8/10/4 5/21/4 4/9/4\nf 3/12/5 2/22/5 5/13/5\nf 1/15/6 3/23/6 8/16/6"; export class Utils { static loadFile(e) { let t = null, r = new XMLHttpRequest; return r.open("GET", e, !1), r.send(), 200 == r.status ? t = r.responseText : console.error("XMLHTTP error (", e, "): ", r.status), t } } export class FrameBuffer { constructor() { this.properties = {}, this.FBO = gl.createFramebuffer(), this.RBO = gl.createRenderbuffer(), this.type = gl.FRAMEBUFFER } bind() { gl.bindFramebuffer(this.type, this.FBO), gl.bindRenderbuffer(gl.RENDERBUFFER, this.RBO) } addTexture(e, t, r, i = gl.TEXTURE0, a = gl.LINEAR, n = gl.LINEAR) { gl.activeTexture(i), this.bind(); let s = gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D, s), gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, t, r, 0, gl.RGBA, gl.UNSIGNED_BYTE, null), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, a), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, n), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE), this.properties[e] = s, gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, s, 0) } static bindDefault() { gl.bindFramebuffer(gl.FRAMEBUFFER, null) } static createRenderTexture(e, t) { let r = new FrameBuffer; return r.bind(), r.properties.width = e, r.properties.height = t, r.properties.texture = null, gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH24_STENCIL8, r.properties.width, r.properties.height), gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, r.RBO), r.addTexture("texture", r.properties.width, r.properties.height), gl.bindRenderbuffer(gl.RENDERBUFFER, null), r } static renderToRenderTexture(e, t) { e.bind(), IngeniumWeb.window.clear(), gl.viewport(0, 0, e.properties.width, e.properties.height), t() } static setDefaultRenderBuffer() { FrameBuffer.bindDefault(), IngeniumWeb.window.clear(), gl.viewport(0, 0, IngeniumWeb.window.width, IngeniumWeb.window.height) } } FrameBuffer.buffers = []; export class Mathematics { static lerp(e, t, r) { return e * (1 - r) + t * r } } export class AnimatedMesh3D { constructor(e, t = [], r = 0, i = 1) { this.meshes = [], this.currentFrame = 0, this.startFrame = 0, this.endFrame = 0, this.frameTime = 1, this.lastFrame = Date.now(), this.interpolating = !0, this.interpolatingTint = !0, this.interpolatingVerticies = !0, this.meshes = t, this.endFrame = r, this.frameTime = i, this.primaryMesh = e } checkAdvanceFrame() { if (Date.now() - this.lastFrame >= this.frameTime) { this.currentFrame < this.endFrame ? this.currentFrame++ : this.currentFrame = this.startFrame, this.lastFrame = Date.now(); let e = this.meshes[this.currentFrame]; this.primaryMesh.material = e.material, this.primaryMesh.triangles = e.triangles, this.interpolating || (this.primaryMesh.mVAO = e.mVAO, this.primaryMesh.mVBO = e.mVBO, this.primaryMesh.data = e.data, this.primaryMesh.tint = e.tint) } if (this.interpolating) { let e = this.currentFrame + 1 > this.endFrame ? this.startFrame : this.currentFrame + 1, t = (Date.now() - this.lastFrame) / this.frameTime; if (this.interpolatingVerticies) { let r = this.meshes[e].getRawVertexdata(0, this.meshes[e].data.length), i = this.meshes[this.currentFrame].getRawVertexdata(0, this.meshes[this.currentFrame].data.length); for (let e = 0; e < i.length; e++)i[e] = Mathematics.lerp(i[e], r[e], t); this.primaryMesh.setRawVertexData(0, i) } else this.primaryMesh.setRawVertexData(0, this.meshes[this.currentFrame].getRawVertexdata(0, this.meshes[this.currentFrame].data.length)), this.interpolatingTint ? this.primaryMesh.tint = Vec3.lerp(this.meshes[this.currentFrame].tint, this.meshes[e].tint, t) : this.primaryMesh.tint = this.meshes[this.currentFrame].tint } } render(e, t, r = new DirectionalLight, i = []) { this.primaryMesh.render(e, t, r, i) } }

        let cubeAnim = [`v -1.000000 -1.000000 1.000000
v -1.000000 1.000000 1.000000
v -1.000000 -1.000000 -1.000000
v -1.000000 1.000000 -1.000000
v 1.000000 -1.000000 1.000000
v 1.000000 1.000000 1.000000
v 1.000000 -1.000000 -1.000000
v 1.000000 1.000000 -1.000000
vt 0.625000 0.000000
vt 0.375000 0.250000
vt 0.375000 0.000000
vt 0.625000 0.250000
vt 0.375000 0.500000
vt 0.625000 0.500000
vt 0.375000 0.750000
vt 0.625000 0.750000
vt 0.375000 1.000000
vt 0.125000 0.750000
vt 0.125000 0.500000
vt 0.875000 0.500000
vt 0.625000 1.000000
vt 0.875000 0.750000
vn -1.0000 0.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 0.0000 1.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 1.0000 0.0000
s off
f 2/1/1 3/2/1 1/3/1
f 4/4/2 7/5/2 3/2/2
f 8/6/3 5/7/3 7/5/3
f 6/8/4 1/9/4 5/7/4
f 7/5/5 1/10/5 3/11/5
f 4/12/6 6/8/6 8/6/6
f 2/1/1 4/4/1 3/2/1
f 4/4/2 8/6/2 7/5/2
f 8/6/3 6/8/3 5/7/3
f 6/8/4 2/13/4 1/9/4
f 7/5/5 5/7/5 1/10/5
f 4/12/6 2/14/6 6/8/6

`, `v -1.000000 -0.541196 1.306563
v -1.000000 1.306563 0.541196
v -1.000000 -1.306563 -0.541196
v -1.000000 0.541196 -1.306563
v 1.000000 -1.306563 0.541196
v 1.000000 0.541196 1.306563
v 1.000000 -0.541196 -1.306563
v 1.000000 1.306563 -0.541196
vt 0.625000 0.000000
vt 0.375000 0.250000
vt 0.375000 0.000000
vt 0.625000 0.250000
vt 0.375000 0.500000
vt 0.625000 0.500000
vt 0.375000 0.750000
vt 0.625000 0.750000
vt 0.375000 1.000000
vt 0.125000 0.750000
vt 0.125000 0.500000
vt 0.875000 0.500000
vt 0.625000 1.000000
vt 0.875000 0.750000
vn -1.0000 0.0000 0.0000
vn -0.2028 -0.3747 -0.9047
vn 1.0000 0.0000 0.0000
vn 0.2028 -0.3747 0.9047
vn 0.4472 -0.8263 0.3423
vn -0.4472 0.8263 0.3423
vn 0.2028 0.3747 -0.9047
vn -0.2028 0.3747 0.9047
vn -0.4472 -0.8263 -0.3423
vn 0.4472 0.8263 -0.3423
s off
f 2/1/1 3/2/1 1/3/1
f 4/4/2 7/5/2 3/2/2
f 8/6/3 5/7/3 7/5/3
f 6/8/4 1/9/4 5/7/4
f 7/5/5 1/10/5 3/11/5
f 4/12/6 6/8/6 8/6/6
f 2/1/1 4/4/1 3/2/1
f 4/4/7 8/6/7 7/5/7
f 8/6/3 6/8/3 5/7/3
f 6/8/8 2/13/8 1/9/8
f 7/5/9 5/7/9 1/10/9
f 4/12/10 2/14/10 6/8/10`];

        let shader;
        let camera3D = new Camera3D();
        let am;
        function onCreate() {
            IngeniumWeb.defaultInit();
            shader = Shader.make3D();
            let tmpMshs = [];
            for (let i = 0; i < 2; i++) {
                let tmpMesh = new Mesh3D();
                tmpMesh.loadFromObjData(cubeAnim[i]);
                tmpMesh.material.diffuseTexture = Mesh3D.createColorTexture(0xffaabb);
                tmpMesh.material.normalTexture = Mesh3D.createColorTexture(0x8080ff);
                tmpMshs.push(tmpMesh);
            }
            am = new AnimatedMesh3D(Mesh3D.createEmpty(36), tmpMshs, 1, 500);
            am.primaryMesh.position = new Vec3(0, 0, 3);
        }
        function onUpdate() {
            camera3D.stdControl(4, PI);
            am.checkAdvanceFrame();
            am.primaryMesh.rotation.addEquals(Vec3.filledWith(0.4).mulFloat(Time.deltaTime));
            am.render(shader, camera3D);
        }
        IngeniumWeb.start([], onCreate, onUpdate);

    </script>
</body>

</html>